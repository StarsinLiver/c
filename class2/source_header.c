// 다중 소스파일과 헤더 파일

// [ 과정 ]
// 컴파일러는 함수의 선언을 통해 함수가 올바르게 호출되었는지만 확인할 뿐, 실제 함수 호출과 정의의 연결은 링커에 의해 수행됨

// main.c -(컴파일)> main.obj (이진파일) -(링크)> main.exe
// sub.c -(컴파일)> sub.obj (이진파일) -(링크)> main.exe (결합)

// 1. 소스파일 (main.c , sub.c)을 컴파일하면, 오브젝트 파일 main.obj , sub.obj 이 생성된다.
// 2. 링커(linker) 가 오브젝트 파일들을 합쳐서 (link) 하나의 실행파일 (main.exe)을 생성한다.

// 위 과정은 여러 개의 소스파일로 구성되어 있는 프로그램을 컴파일하여 실행파일을 생성하는 과정을 나타낸다.
// 먼저 소스파일을 따로 컴파일한 다음에, 링커로 컴파일된 파일들을 연결(link)해서 하나의 실행파일을 생성한다.

// 이처럼 소스파일별로 따로 컴파일 하기 때문에, 프로그램의 일부가 변경되어도 모든 소스파일을 컴파일 하지 않고 변경된 소스파일만 다시 컴파일한 후 링크하면 된다.

// 또 다른 장점으로는 여러 사람이 동시에 프로그램을 개발할 수 있다는 것인데, 소스파일 sub.c 에 선언된 함수들의 몸통이 완성되지 않은 상태에서도 main.c 를 작성하는 것이
// 가능하다.

// 함수들을 기능별로 나누어 서로 관련된 것들 끼리 같은 소스파일에 작성하는 것이 일반적이며, 이렇게 나누어 작성된 소스코드들은 다른 프로그램에 재사용될 수도 있다.
// 만일 다른 사람에게 자신이 작성한 코드가 공개되는 것을 원하지 않는 경우, 소스파일 없이 컴파일된 파일(sub.obj)만으로도 다른 프로그램에 포함시킬 수 있다.
// 대신 컴파일된 파일에 포함되어 있는 함수들의 선언부는 공개해야 해당 함수들을 사용할 수 있다.

// main.c -(컴파일)> main.obj (이진파일) -(링크)> main.exe
//                   sub.obj (이진파일) -(링크)> main.exe (결합)



// [ 헤더 파일 .h ]
// 헤더 파일은 전처리기 지시자 '#include'로 소스파일에 포함시킬 헤더 파일의 이름을 명시한다. 이렇게 하면, 변경사항이 발생해도 헤더 파일 하나만 관리하면 되므로
// 코드의 중복도 제거되고 오류가 발생할 가능성도 줄어든다.
// 그래도 여전히 함수의 선언부가 바뀌었을 때 함수가 호출되는 부분은 직접 변경해 주어야 한다.

// 소스파일에 포함시킬 헤더파일을 지정할 때, 표준 라이브러리의 헤더파일은 이름을 '<>' 로 감싸지만, 그 외의 경우는 큰따옴표로 감싸야 한다.
// 그리고 대소문자를 구분해서 적어주는 것이 좋다. 윈도우의 경우 파일이름에 대소문자를 구별하지 않지만, 유닉스나 리눅스는 대소문자를 구별한다.

// #include <stdio.h>
// #include "sub.h"

// 헤더파일을 감싸는 기호는 전처리기가 헤더파일이 저장된 위치를 파악하는 데 사용된다. '()' 로 감싸진 헤더파일은 '미리 약속된 경로(file path)'에 있다는 것이고, 
// 큰따옴표로 감싸진 헤더파일은 소스파일과 같은 디렉토리 (폴더)에 있다는 의미이다. 만일 소스파일과 다른 디렉토리에 헤더파일이 있다면,
// 헤더파일 이름 앞에 상대경로 또는 절대경로를 붙여 주어야 한다.

// #include "file/path/sub.h"
// #include "C:/file/path/sub.h"

// [ 경로 구분자 ]
// 이때 경로 구분자 (path seperator) 은 \ (유닉스 스타일) 또는 / (윈도우 스타일) 을 사용한다.
// 문자열 내에 '\'를 포함시킬 때는 '\\'와 같이 사용해야 하나 #include 에서 사용하는 큰따옴표는 C언어의 문자열을 표현하기 위한 것이 아닌 전처리기에게 헤더파일의
// 위치를 알려주는 데 사용되는 기호이기 때문에 한번만 사용한다.

// #include "file\path\sub.h" // 유닉스 스타일
// #include "C:/file/path/sub.h" // 윈도우 스타일



// [ 전처리기 지시자 #include ]
// #include 는 전처리기 지시자로 컴파일 직전에 수행된다. 이 지시자가 하는 일은 지정된 헤더파일의 내용을 '#include' 지시자가 있는 위치에 그대로 포함시킨다.
// 우리가 좀 전에 소스파일로 부터 함수의 선언부를 떼어내서 별도의 헤더파일로 분리했던 것과 정반대의 일을 하는 것이다.
// 전처리과정에서 소스파일을 변경하거나, 새로운 파일이 생성되는 것이 아닌, 메모리 내에서 소스파일의 내용을 재구성한 후에 컴파일 단계로 넘어간다.


// main.c
// #include "sub.h"
// int main ...

// sub.h
// void function1(void);

// main.c , sub.h -(전처리)> 하나의 파일로 재구성

// void function1(void);
// #include "sub.h"
// int main ...

// -(컴파일)> main.obj (이진 파일)


// [ #include ]
// #include 는 지정된 파일의 내용이면 무엇이든 있는 그대로 포함시키기 때문에 헤더 파일 뿐만아니라 어떤 파일도 지정이 가능하다.
// 헤더파일에도 반드시 함수의 선언부만 포함해야 하는 것은 아니므로 열거형 , 사용자 정의 타입 , 매크로 함수, 상수 등 여러 소스파일에서 공통적으로 사용하는 것들도
// 헤더파일에 포함시키면 좋다.

// 심지어 헤더파일 내에 #include 로 또 다른 헤더 파일을 포함시키는 것도 가능하다

// 이처럼 헤더파일안에 '#include'가 반복적으로 중첩이 가능하기 때문에 프로그램의 크기가 커지다보면 실수로 하나의 소스파일에 같은 헤더파일이 여러번 포함되는 일이
// 발생할 수 있다. 이러한 헤더파일의 중복을 막으려면 '#pragma once' 나 '#ifndef' 와 같은 전처리기 지시자를 사용해야 한다.
