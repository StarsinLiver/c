## 기억 부류 지정자 (storage class specifier)
'기억 부류 지정자'는 변수가 메모리의 어느 영역에 저장될 것인지를 결정한다. <br/>
메모리는 몇개의 영역으로 나뉘어 있는데 각 영역마다 다른 특징을 가지고 있으며, 어느 영역에 저장되느냐에 따라 변수의 생존기간 (storage duration)이 달라진다.
<br/>
기억 부류 지정자는 아래와 같이 4가지가 있는데, 이 중에서 auto , register 는 거의 사용되지 않고 실제로 사용되는 것은 extern 과 static 이다.

```
> extern , static , auto , register


> extern   : 전역변수 , 함수 : 프로그램의 시작부터 끝까지 , 자동 초기화됨 
> static   : 전역변수 , 함수 : 프로그램의 시작부터 끝까지 , 자동 초기화됨
> auto     : 지역변수 : 선언문 부터 함수(블럭)의 끝까지 , 자동 초기화 안됨
> register : 지역변수 : 선언문 부터 함수(블럭)의 끝까지 , 자동 초기화 안됨
```

## auto 와 register
'auto' 는 지역 변수 앞에 붙이는 거억 부류 지정자인데, 함수 내에 선언된 변수중에 static 이 안붙은 변수는 모두 지역변수이므로 auto 를 굳이 붙일 필요가 없다.

```
void func(void) {
  auto int lv = 1;    // 지역변수 선언. auto 생략 가능
  register int i = 1; // 레지스터 변수 선언. 변수를 레지스터에 저장
}
```

'register' 역시 지역변수 앞에만 붙일 수 있는데, 변수를 메모리가 아닌 레지서터에 저장하라고 지정하기 위한 것이다.

레지스터는 CPU내에 있는 저장 공간으로 CPU 의 외부에 있는 메모리보다 읽고 쓰는 속도가 상당히 빠르다.

그래서 자주 사용되는 변수에 기억 부류 지정자 'register'를 붙여주면 성능이 향상된다.
다만, 레지스터는 공간이 적어서 저장할 수 있는 변수의 개수에 제약이 있다. 'register'가 붙어있는 지역 변수라도 레지스터에 저장할 공간이 부족하면 메모리에 저장된다.

C언어가 처음 탄생했을 때, 컴파일러의 기능이 약하고 프로그래머들이 기계어를 잘 알고 있었기 때문에 레지스터를 사용할 것이지에 대해 판단을 스스로 했으나 컴파일러의 성능이 향상되면서 지역변수에 'register'를 붙이지 않아도 컴파일러가 알아서 레지스터를 적절히 사용하므로, 저장 부류 지정자 'register'는 더 이상 사용되지 않는다.

## extern 과 static
extern 은 변수 앞에서 외부에 선언된 변수라는 것을 알리며, 즉 참조적 선언을 하는데 사용된다. 컴파일러는 소스파일 단위로 작업을하기 때문에 소스파일간의 연결을 할 수 없다. 그저 소스파일이 외부 (다른 소스파일)에 정의된 변수를 사용한다는 정보만 오브젝트 파일(*.obj)에 남길 뿐이다. 이 정보를 이용해서 참조적 선언을 실제 선언과 연결하는 것은 링커의 몫이다.

변수 뿐만 아니라 함수에도 기억 부류 지정자를 붙일 수 있는데, 함수는 변수와 달리 항상 프로그램의 시작부터 끝까지 메모리에 존재하므로, 함수 앞에 붙은 기억 부류 지정자는 함수의 유효범위를 결정하는 역할을 한다.
함수 앞에 붙일 수 있는 기억 부류 지정자는 extern 과 static 두개 뿐이다.

```
[ 유효 범위 ]
extern : 프로그램 전체
static : 함수가 정의된 소스파일
```

"함수에 붙일 수 있는 기억 부류 지정자는 extern, static 인데 extern 일때는 무조건 생략하고, static일 때는 선언과 정의에 모두 붙인다."


## 링커와 extern
먼저 C언어에서는 하나의 프로그램을 여러 개의 소스파일로 나누고, 소스파일단위로 컴파일한 후 링커를 이용해서 하나의 프로그램으로 연결하는 작업을 수행하는 전략을 취한다.

컴파일러는 한번에 하나의 소스파일만 컴파일 하기때문에, 다른 소스파일에 존재하는 전역변수나 함수의 정보를 알지 못한다. 그래서 여러 소스파일에서 공통적으로 사용하는 것들에 대한 정보를 헤더파일에 저장하고, 이 헤더파일을 각 소스파일에 포함시킨다.

이제 컴파일러는 다른 소스파일에 존재하는 대상들의 정보를 가지고 있으므로 컴파일을 수행할 수 있지만, 한번에 하나의 소스파일만 컴파일하기 때문에 서로 다른 파일에 존재하는 정의와 호출을 연결하지 못한다.

이 둘을 연결하는 것이 바로 링커의 역할 이며, 링커는 각 컴파일된 파일에 정의된 전역 변수와 함수 중에서 기억 부류 지정자 'extern'이 붙은 것들을 찾아내서 연결한다.

반면 'static'이 붙은 것들은 연결하지 않는다. 엄밀히 말하면 , 컴파일러는 static 이 붙은 대상들을 링커가 알 수 없도록 숨긴다.

```
[ 목적 ]
extern : 링커에게 노출시키려는 전역변수나 함수에 사용 (생략 가능)
static : 전역 변수와 함수의 유효범위를 제한하기 위해 사용 (링커에게 함수를 노출시키지 않으려 할 때 사용)
```