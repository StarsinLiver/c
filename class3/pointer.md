## Pointer
포인터를 이해하기 위해서는 먼저 메모리 주소에 대해 알아보자. 메모리의 종류에는 여러가지가 있지만 여기서는 컴퓨터에 장착된 램(RAM)을 의미한다.
메모리는 물리적으로 여러 개의 칩으로 구성되어 있지만, 운영체제(OS)는 메모리를 하나의 연속된 저장공간으로 간주한다.

그리고 이 저장 공간을 1byte 단위로 나누어 0부터 시작하여 1씩 증가하는 일련번호를 붙인 것이 메모리 주소이다.

32bit OS 의 경우 한번에 다룰 수 있는 데이터의 크기가 32bit (=4byte) 이므로, 메모리에 부여할 수 있는 주소의 범위는 19진수로 '0 ~ 2의32승 - 1' , 16진수로 '0x0 ~ 0xFFFFFFFF' 가 된다. 그래서 32bit OS는 최대 4GB(2의 32승)의 메모리를 다룰 수 잇는 것이다. 아무리 많은 용량의 메모리가 장착되어 있는 64bit 컴퓨터라도 32bit OS 를 사용한다면 하나의 프로세스가 최대 4GB의 메모리 밖에 사용할 수 없다.

여기서는 이해가 쉽도록 32bit OS 를 기준으로 설명한다.

## 변수와 메모리 주소
아래의 문장이 수행되면 메모리에 int 타입의 값(4byte)을 위한 저장 공간이 마련되고 그 저장 공간에 1이 저장될 것이다.

> int i = 1; // int 타입의 변수 i 를 선언하고 1을 저장

변수 i는 메모리의 어딘가에 분명히 저장되어 있을 것이므로, 저장된 곳의 주소가 있을 것이다. 그 주소를 0x100 이라고 가정한다면

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

[ 메모리 ] == i
0x100 : 00
0x101 : 00
0x102 : 00
0x103 : 01

값 : 0x00000001
```

변수 i는 타입이 int 이므로 i 를 위한 저장공간은 메모리 주소 0x100 부터 0x103까지 모두 4byte가 필요하다. 이때 변수 i의 주소는 i가 저장된 범위의 시작주소인 0x100이다.
변수 i의 타입이 int 이므로 시작주소가 0x100 것만 알면 저장범위가 0x100 ~ 103이라는 것은 쉽게 알 수 있다. 그래서 어떤 대상의 주소는 항상 그 대상이 저장된 범위의 시작주소를 의미한다.

> "어떤 대상의 주소는 저장된 범위의 시작 주소를 의미한다."


## 포인터란?
포인터는 영어로 '무엇을 가리키다.' 라는 뜻의 동사 'point'에 명사형 어미 'er'이 붙은 것으로 '무엇을 가리키는 것' 이라는 뜻의 명사다

포인터는 메모리에 저장된 것 예를 들어 변수나 배열을 가리키기 위한 것이다. 가리킨다는 것은 포인터가 어떤 대상의 주소를 저장하고 있다는 것을 의미한다. 아래의 그림은 포인터 ptr 이 변수 i를 가리키고 있는 상황을 표현한 것으로 포인터 ptr 에 변수 i의 주소인 0x100이 저장되어있는 것을 알 수 있다.

> ptr [ 0x100 ] ----> i [ 0x100 , 값 : 1]

결국 포인터는 메모리 주소 (부호없는 정수)를 저장하기 위한 변수인 것이다. 선언하는 방법, 값을 저장하고 읽어오는 방법 모두 변수와 같다. 포인터는 메모리 주소를 저장하기 위한 것이라는 것만 다르다.

> "포인터는 메모리 주소를 저장하기 위한 변수"

변수와 마찬가지로 포인터도 const 키워드를 붙여서 상수로 만들 수 있으며 이를 '포인터 상수'라고 부른다. 포인터를 '포인터 상수'와 구분하기 위해서 '포인터 변수'라고 하는데, 꼭 필요한 경우를 제외하고 간단히 '포인터'라고 부른다.

## 포인터의 선언
포인터의 선언방법은 변수의 선언방법과 동일하다. 다만 포인터가 가리키는 대상의 타입에 '*'를 붙인다.
```
> 타입* 포인터명; // 지정된 타입의 값을 가리키기 위한 포인터 선언
> int* ptr;
```

위와 같이 포인터 ptr 를 선언했을 때 ptr 의 타입이 'int' 가 아닌 것에 주의하자.

ptr 이 가리키는 대상의 타입이 'int'이고, ptr 의 타입은 'int*' 이다. 선언문 '타입 이름;' 에서 이름을 빼고 남는 것은 바로 타입이다. 포인터 선언문 'int* ptr' 에서 포인터의 이름 ptr 을 제외하고 남는 'int*' 가 바로 ptr 의 타입이다.

포인터임을 알리는 기호 '*'는 타입 뒤에 붙여도 되고 포인터 이름 앞에 붙여도 된다. 타입과 포인터 이름 사이에 두는것도 가능하다
```c
[ 전부 가능 ]
int* ptr;
int * ptr;
int *ptr;
```
여러 포인터를 함께 선언한 때는 포인터 이름 앞에 '*' 기호를 붙이는 것이 좋다. 그렇지 않으면 의도한 것과 전혀 다른 선언이 되어 버릴 수 있다.

```c
int *ptr1 , *ptr2; // ptr1 , ptr2 모두 'int*' 타입의 포인터로 선언

int* ptr1 , ptr2; // ptr1 만 포인터로 선언됨. ptr2 의 타입은 'int'
```

주의하자

## 포인터에 주소 저장하기 - & 연산자
포인터에 주소를 저장하려면 먼저 포인터가 가리킬 대상의 주소를 얻어야하는데 그 일을 하는 것이 '&연산자(주소 연산자)' 이다.

'&'연산자는 피연산자가 하나인 단한 연산자로 '&피연산자'의 형태로 사용된다. '&'연산자는 피연산자의 주소를 반환하며, 피연산자로 변수나 배열요소처럼 저장공간을 가지고 있는 것만 허용된다.

아래의 코드는 변수 i와 포인터 ptr 을 선언하고 , &연산자로 변수 i의 주소를 얻어서 포인터 ptr 에 저장한다.
```
int i = 1;
int *ptr = &i; // 변수 i의 주소를 포인터 ptr 에 저장
```

변수 i 의 주소가 0x100 이라고 가정하면 위의 문장은 다음과 같은 과정으로 처리된다.

```
int* ptr = &i; // &연산자로 변수 i의 주소 (0x100)을 얻어온다.
int* ptr = 0x100; // 0x100을 ptr 에 저장


> ptr [ ]               i [ 0x100 , 값 : 1]
> ptr [ ]  <-- 0x100 -- i [ 0x100 , 값 : 1]
> ptr [ 0x100 ]  --->   i [ 0x100 , 값 : 1]
```

포인터 ptr 이 변수 i를 가리키고 있다는 의미로 화살표를 그려넣었으며, 이제 변수 이름인 i뿐만 아니라 포인터 ptr를 통해서도 변수 i에 접근이 가능하다.

```c

  int i = 5;
  int* p = &i;

  printf("i : %d\n" , i);
  printf("&i : %d\n" , &i);
  printf("p : %d\n" , p);
  printf("&p : %d\n" , &p);

/*
i : 5
&i : 6422044
p : 6422044
&p : 6422032
*/
```

실행할 때마다 프로그램이 메모리에 올라가는 주소가 달라지므로 매번 결과가 달라진다.

메모리주소 출력을 위한 지시자는 '%p' 이다. 주소 앞에 접두사 '0x'를 붙이고 싶으면, 지시자 '%#010x'를 사용하면 된다. '#'는 접두사 '0x'를 의미하고 '010'dms 전체 10자리 (접두사 포함) 중 빈자리는 0으로 채우라는 뜻이다.

```c
  int i = 5;

  printf("%p : %p\n" , &i);
  printf("%#010x : %#010x\n" , &i);
  printf("%#010X : %#010X\n" , &i);

/*
000000000061FE14 : 0000000000672610
0x0061fe14 : 0xd5a2e7a0
0X0061FE14 : 0XD5A2E7A0
*/
```

## 포인터로 값 읽어오기 - * 연산자
포인터가 가리키는 대상에 저장된 값을 가져올 때는 '*'연산자를 사용한다. '*' 연산자는 '간접 참조 연산자(dereference operator)' 라고 하는데, '*피연산자'의 형태로 사용되는 단항 연산자로 피연산자(포인터)가 가리키는 주소에 저장된 값을 읽어서 반환한다.

간접 참조 연산자 '*'는 곱셈 연산자와 같은 기호를 사용하지만 피연산자의 개수로 구분이 가능하다.

> '*' 연산자 (간접 참조 연산자)는 지정된 주소에 저장된 값을 반환한다.

```c
  int i = 200;
  int* ptr = &i; // i 의 주소값을 저장한다.

  printf("i : %d\n" , i);
  printf("*ptr : %d\n" , *ptr);

/*
i : 200
*ptr : 200
*/
```

위의 코드는 변수 i의 주소가 0x100라고 가정하면, '*ptr'은 '*'연산자가 피연산자인 ptr 이 가리키는 주소에 저장된 값을 가져온다.
뿐만 아니라 'i' 와 '*ptr'은 식에서도 동등한 것으로 취급된다. 즉, 변수이름인 'i' 대신 '*ptr'을 사용할 수 있는것이다.

아래의 두 코드는 동등하다.

```
[ 1 ]
int i = 200;
int* ptr = &i;
i = i + 1;

[ 2 ]
int i = 200;
int* ptr = &i;
*ptr = *ptr + 1;
```

그렇다고 해서 변수 이름 'i' 와 '*ptr' 이 완전히 동일한 것은 아니다. '*ptr'은 포인터를 통해서 간접적으로 변수에 접근하는 것이기 때문에 변수 이름으로 직접 접근하는 것에 비해 비효율적이다.

```c
  int i = 200;
  int* ptr = &i; // i 의 주소값을 저장한다.

  printf("i : %d\n" , i);
  printf("*ptr : %d\n" , *ptr);

  printf("&i : %d\n" , &i);
  printf("ptr : %d\n" , ptr);

/*
i : 200
*ptr : 200
&i : 6422036
ptr : 6422036
*/
```

## & 연산자와 * 연산자 비교
주소 연산자 '&'는 저장공간의 주소를 반환하고, 간접 참조 연산자 '*'는 주소에 저장된 값을 반환한다. 즉, 이 두연산자는 서로 반대의 일을 한다.

```
'&' 연산자의 반환값 : 저장공간 (변수)의 주소
'*' 연산자의 반환값 : 주소에 저장된 값
```

지금까지 '&' 연산자와 '*' 연산자의 연산결과값, 즉 반환값에 대해서만 얘기하고 '반환값의 타입'에 대해서는 별로 관심을 갖지 않았는데, 사실 연산자의 반환값 못지않게 중요한 것이 반환값의 타입(반환타입 , 결과타입)이다.

반환 타입에서도 두 연산자는 상반된 결과를 보인다. '&' 연산자의 반환타입은 피연산자의 타입에 '*' 을 추가한 것이고, '*'연산자는 반대로 피연산자의 타입에서 '*'를 제거한 반환타입이다. 그래서 타입에 '*'기호가 포함된것만 '*'연산자의 피연산자가 될 수 있다.

```
'&' 연산자의 반환타입 : 피연산자의 타입에 '*' 추가
'*' 연산자의 반환타입 : 피연산자의 타입에서 '*' 제거
```

아래 코드는 우변의 타입을 따져보면 좌변의 타입과 일치하는 것을 알 수 있다.

```c
[ 1 ]
  int i = 200;
  int* ptr = &i; // & 반환 타입은 * 이다.

[ 2 ]
  int tmp = *ptr; // * 반환 타입은 '*' 뺀 타입이다.
```

밑의 박스는 변수 i 와 포인터 p에 '&' 연산과 '*' 연산을 수행했을 때, 결과값과 결과 타입의 변화를 보여준다.

```
[ 1 ]
변수 : i [int] -- ( & ) --> 주소 : &i [int*] -- (*) --> 변수 : *&i [int] == i

[ 2 ]
주소 : P [int*] -- ( * ) --> 변수 : *P [int] -- (&) --> 주소 : *&P [int*] == P
```

위의 과정들을 살펴보면 '&' 연산을 수행하면 피연산자의 타입에 '*' 이 추가되고, '*'연산을 수행하면 '*'이 제거된다는 것을 알 수 있다. 그래서 포인터든 변수든 '*' 연산과 '&'연산을 동시에 적용하면 원래의 타입으로 돌아온다.


## 포인터의 타입
포인터의 타입은 포인터가 가리키는 대상의 타입에 '*'을 추가한 것이다. 만일 포인터가 가리키는 대상의 타입이 'int' 라면 이 포인터의 타입은 'int*' 이어야 한다.

> 포인터의 타입은 '포인터가 가리키는 대상의 타입에 '*'를 추가한 것

즉, 포인터의 타입은 '포인터의 대상타입'과 포인터임을 알리는 기호 '*'로 이루어지는데 포인터의 타입에 포함된 '*'는 기호일 뿐 연산자가 아니다. 그 외의 경우에 나타나는 '*'은 모두 간접참조연산자이다.

포인터의 타입에 포함된 기호 '*'가 의미하는 것은 선언대상이 '포인터' 라는 것과 간접참조연산 '*'이 가능하다는 것이며, '*' 연산자로 메모리에 저장된 값을 읽어오려면 주소만으로 부족하다. 해당 주소에서 몇 바이드를 읽어 와서 어떻게 해석할지에 대한 정보도 필요한데 이런 정보들은 '포인터의 대상타입'이 제공한다.

```
int* ptr;

포인터의 대상 타입     : int
포인터임을 알리는 기호 : *

포인터의 타입          : int*
```

만일 int 타입의 변수 i 를 포인터 ptr 이 가리키고 있다면, ptr에 저장된 값인 '0x100'이 포인터가 가리키는 값의 주소에 대한 정보를, ptr의 대상타입인 'int'가 몇 바이트를 읽어와서 어떻게 해석할 지에 대한 정보를 제공하는 것이다.

따라서 만일 포인터가 가리키는 대상의 타입이 int 라면 sizeof(int)의 결과인 4byte 만큼 읽어온다.

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 00
0x101 : 00
0x102 : 00
0x103 : 01

0 00000000 00000000 00000000 00000001
```

여기서 중요한 것은 포인터가 가리키는 주소에서 읽어온 값이 0x00000001 이라고 해서 이 값을 당연히 숫자 1이라고 생각하면 안된다는 것이다. 포인터의 타입이 'int*'이니까 int 타입의 형식으로 해석되어 1인 것이지, 만일 포인터의 타입이 'float*' 이었다면 이 값은 1이 아닌 '1.401298e-45' 로 해석되었을 것이다.


## 포인터의 형변환
포인터의 타입도 형변환이 가능하며, 형변환 방법은 기본형과 동일하다.

포인터의 타입이 의미하는 것은 '얼마만큼의 데이터를 읽어와서 어떻게 해석할 것인지'이므로, 포인터가 다른 포인터 타입으로 형변환되면 '읽어올 데이터의 양과 해석방법'이 달라질 뿐 포인터에 저장된 값(주소)에는 아무런 영향을 미치지 않는다.

그리고 같은 주소에서 '읽어올 데이터의 양과 해석방법'은 여러가지가 존재할 수 있으므로, 포인터를 다양한 포인터 타입으로 자유롭게 형변환하는 것이 허용된다.

```
  int i = 0x1B2B3B4B;
  int* pi = &i;

  char* pc = (char*) pi;
```

위와 같은 코드가 있을 때, 포인터 pi 에 저장된 주소를 포인터 pc 에 저장하면 형변환이 필요하다. 대입 연산자의 양변은 타입이 일치해야 하기 때문이다. 

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

  int i = 0x1B2B3B4B;
  int* pi = &i;

[ 1 ]
[ 메모리 ] == pi [0x100]

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

[ 2 ]
  char* pc = (char*) pi;

[ 메모리 ] == pi [0x100]

[ 메모리 ] == pc [0x100]

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

> 포인터 pi 의 값을 포인터 pc 에 형변환을 해 저장을 해도 저장된 값(주소)에는 아무런 변화가 없다.
```

이제 pi 뿐만 아니라 pc 를 이용해서도 변수 i 에 접근할 수 있다. 포인터 pi 와 pc 모두 변수 i를 가리키고 있지만, 서로 타입이 다르기 때문에 '*연산자'를 이용해서 읽어올수 있는 값의 크기가 다르다. *pi 는 4byte 를 읽어오지만, *pc 는 1byte 만 일거올다. 포인터 pc 의 대상타입이 'char(1byte)' 이기 때문이다.

```
[ 메모리 ] == pi [0x100]
pi 는 4byte 를 읽어 올수 있다. 
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

[ 메모리 ] == pc [0x100]
pc 는 1byte 를 읽어 올수 있다. 
0x100 : 1B
```

short 도 추가해보자

```c
  int i = 0x1B2B3B4B;
  int* pi = &i;

  char* pc = (char*) pi;
  short *ps = (short*)pi;

  printf("&i : %d\n" , &i);
  printf("pi : %d\n" , pi);
  printf("pc : %d\n" , pc);
  printf("ps : %d\n" , ps);

  printf("*pi : %X\n" , *pi);
  printf("*pc : %X\n" , *pc);
  printf("*ps : %X\n" , *ps);
  printf("*(int*) pc = %X\n" , *(int*) pc);

/*
&i : 6422020
pi : 6422020
pc : 6422020
ps : 6422020
*pi : 1B2B3B4B
*pc : 4B
*ps : 3B4B
*(int*) pc = 1B2B3B4B
*/
```

실행결과를 보면 예상과 달리 '*pc'의 연산결과로 '1B'가 아닌 '4B'가 출력되었는데 그 이유는 위 예제를 실행한 시스템의 CPU가 사용하는 '바이트 순서(byte order)' 가 '리틀 엔디안' 이기 때문이다. 리틀 엔디안 방식을 사용하는 CPU는 데이터를 역순으로 저장한다.

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

int i = 0x1B2B3B4B;

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 4B
0x101 : 3B
0x102 : 2B
0x103 : 1B
```

그리고, 포인터 pc 는 pi 와 같은 주소를 가리키기 때문에, pc를 'int*' 으로 형변환하기만 하면 pc 로도 pi 처럼 4byte의 데이터를 읽어 올수 있다.

## 빅엔디안과 리틀엔디안 (Big endian & Little endian)
4 byte 데이터 (0x1B2B3B4B)를 저장하면, 순서대로 저장될 수도 그렇지 않은 CPU 도 있다. 인텔 CPU는 데이터를 역순으로 저장한다.

```
[ Big endian ]
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

[ Little endian ]
0x100 : 4B
0x101 : 3B
0x102 : 2B
0x103 : 1B
```

사람이 읽고 쓰는 것처럼 높은 자리부터 순서대로 저장하는 방식을 '빅 엔디안 (Big endian)' 이라고 하고, 그 반대로 저장하는 방식을 '리틀 엔디안 (Little endian)' 이라고 한다. 인텔 CPU는 리틀 엔디안 방식을 사용한다.

> 포인터를 사용하려면 우선 CPU 가 어떤 방식을 사용하는 지 알아 보는 것도 중요하다.

## 포인터를 기본형으로 변환
모든 타입의 포인터에 저장된 값을 항상 '부호 없는 정수' 이므로, 포인터 타입을 기본형으로 변환할 때는 부호 없는 정수타입으로 변환하는 것이 적절하다.

```c
  int i = 1;
  int* pi = &i; // 0x100 주소로 가정 

  unsigned addr = (unsigned)pi; // 포인터 타입을 정수로 형변환 addr = 0x100
```

32 bit OS 에서는 포인터 타입과 int 타입의 크기가 모두 4 byte 이지만, 64 bit OS 에서는 포인터의 타입의 크기가 8byte 이고, int 타입의 크기는 4byte이다. 즉 위의 코드는 64 bit OS 에서 주소의 일부가 잘려서 변수 addr 에 저장될 것이다.

그래서 C언어는 포인터에 저장된 값(주소)과 동일한 크기의 부호없는 정수 타입인 'uintptr_t' 를 제공한다.

아래 코드에서 unsigned 보다 uintptr_t 로 작성하는 것이 이식성이 좋은 코드이다. 이 타입들을 사용하면 32 bit OS 나 64 bit OS 어느쪽에서도 코드의 변경없이 잘 동작할 것이다.

```c
#include <stdio.h>

int i = 1;
int* pi = &i; // 0x100 주소로 가정 

unsigned addr = (unsigned)pi; // 포인터 타입을 정수로 형변환 addr = 0x100
uintptr_t addr2 = (uintptr_t)pi; // 이식성이 좋은 코드
```

포인터 타입을 실수형으로 형변환하는 것은 금지되어 있고, 그렇게 해야 할 경우도 없을 것이다. 그래도 필요하다면 정수형으로 형변환한 다음에 실수형으로 형변환하면 된다.

```c
int* pi = (int*) 0x10; 
// float f = (float) pi; // 에러
float f2 = (float) (unsigned) pi; // OK 
```

0x100 은 10진수로 16이므로 f2 에는 16.0f 가 저장된다.

```c
  int i = 0x1B2B3B4B;
  int* pi = &i;

  unsigned addr = (unsigned) pi;

  printf("addr : %08X, *(char*) addr : %X\n" , addr , *(char*)addr);
  printf("addr+1 : %08X, *(char*) addr : %X\n" , addr+1 , *(char*) (addr + 1));
  printf("addr+2 : %08X, *(char*) addr : %X\n" , addr+2 , *(char*) (addr + 2));
  printf("addr+3 : %08X, *(char*) addr : %X\n" , addr+3 , *(char*) (addr + 3));

/*
addr : 0061FE10, *(char*) addr : 4B
addr+1 : 0061FE11, *(char*) addr : 3B
addr+2 : 0061FE12, *(char*) addr : 2B
addr+3 : 0061FE13, *(char*) addr : 1B
*/
```

변수 i 의 주소를 'unsigned' 타입의 변수 addr 에 저장한 다음, 이 변수의 값을 1씩 증가시켜가면서 간접 참조 연산자 '*' 로 1byte 씩 가져온다. 이렇게 하면 변수 i의 값을 1 byte 씩 읽어올 수 있다.

변수 addr 의 값은 포인터 pi 와 같지만, addr 의 타입은 unsigned 이므로 타입에 '*' 이 없어서 갑접 참조 연산자 '*'의 피연산자가 된 수 없다. 그래서 위와 같이 'char*'로 형변환한 다음에 '*' 연산을 수행해야 한다.

## 포인터의 포인터
포인터도 변수이므로 포인터가 포인터를 가리키는 것이 가능하다, 포인터를 가리키는 포인터를 '포인터의 포인터' 또는 '더블 포인터' 라고 한다.

포인터의 타입은 포인터가 가리키는 대상의 타입에 '*'기호를 추가한 것이므로 만일 포인터 pi의 타입이 'int*' 이라면, 포인터 pi 를 가리키는 포인터의 타입은 'int**' 이다.

```
int i = 100;
int* pi = &i;

int* pi2 = (int*) &pi; // 포인터 pi 를 가리키는 포인터
```

만일 위와 같이 포인터 pi 를 더블 포인터가 아닌 포인터 pi2 로 가리키도록 하면 , 전과 달리 포인터 pi2로 변수 i에 접근이 불가능 하다.

```c
int* pi2 [ 0x200 ] --> int* pi  [ 0x100 ] -- (pi2 접근 불가) --> i

printf("*pi2 : %#x\n" , *pi2); // *pi2 = 0x100 [*pi]
printf("**pi2 : %#x\n" , **pi2); // 에러
```

더블 포인터를 사용했을 때와 달리 포인터 pi2 로는 변수 i 에 접근할 수 없다. pi2 도 ppi 처럼 pi 의 주소를 가지고 있는데 왜 pi2 로는 i에 접근이 불가능 한 것일까?
그 이유는 단지 pi2의 타입이 적절하지 않기 때문이다.

'*' 연산자는 피연산자의 타입에서 '*'를 제거하므로 '*' 연산을 두번 수행하려면 피연산자의 타입에 '*'이 최소한 두 개가 포함되어 있어야 하는데, pi2의 타입은 'int*' 이므로 '*' 연산이 한번밖에 수행할 수 없다.

그러나 pi2 의 타입을 더블 포인터의 타입 (int**)으로 형변환하기만 하면 pi2로도 ppi 처럼 변수 i 에 접근이 가능하다.

```
**(int**) pi2;
```

## 더블 포인터의 포인터
더블 포인터를 가리키는 포인터, 즉 트리플 포인터를 선언할 수 있으며, 그 이상도 얼마든지 가능하다.

대부분의 경우 한 두개가 보통이고 많아야 세개정도인데, 타입에 '*'이 몇개가 붙어있든 모두 포인터일 뿐이다. 그저 규칙에 따라 타입계산만 잘하면 별 어려움 없이 처리가 가능하다.

```
  int i = 100;
  int* pi = &i;
  int** ppi = &pi;
  int* pi2 = (int*) &pi;

  printf("i : %d\n" , i);
  printf("&i : %p\n" , &i);
  printf("pi : %p\n" , pi);
  printf("&pi : %p\n" , &pi);
  printf("ppi : %p\n" , ppi);
  printf("*ppi : %p\n" , *ppi);
  printf("**ppi : %p\n" , **ppi);
  printf("pi2 : %p\n" , pi2);
  printf("*pi2 : %p\n" , *pi2);
  printf("**(int**)pi2 : %d\n" , **(int**)pi2);
  printf("sizeof(pi) : %d\n" , sizeof(pi));
  printf("sizeof(pi) : %d\n" , sizeof(ppi));

/*
i : 100
&i : 000000000061FE0C
pi : 000000000061FE0C
&pi : 000000000061FE00
ppi : 000000000061FE00
*ppi : 000000000061FE0C
**ppi : 0000000000000064
pi2 : 000000000061FE00
*pi2 : 000000000061FE0C
**(int**)pi2 : 100
sizeof(pi) : 8
sizeof(pi) : 8
*/
```

## 포인터 상수와 상수 포인터
const 는 원래 표준 C에 없던 것으로 C++ 에서 가져온 것이다. 필요성이 높이서 C99부터 새로 추가되었다. const 는 앞서 배운 것과 같이 상수를 선언할 때 사용된다.

> 포인터가 가리키는 대상이 상수일 때, 포인터의 타입에도 'const'가 포함 되어야 한다.

이처럼 상수를 가리키는 포인터를 '상수 포인터' 라고 한다.

```c
const int MAX = 999;
const int* ptr = &MAX;
```

포인터가 가리키는 대상이 상수가 아니어도 포인터의 타입 앞에 'const'가 붙어 있으면 포인터로 가리키는 대상의 값을 변경할 수 없게 된다.

```c
int i = 999;
const int* ptr = &i;

  // *ptr = 1; // 에러
```

타입에 'const'가 붙어있는 쪽으로 대입은 형변환이 생략가능하며, 그 반대의 경우 형변환을 생략하면 경고가 발생한다.

```c
  const int MAX = 999;
  int i = 999;

  const int* ptr = (int*) &MAX; // 'const int*' 을 'int*'로 형변환. 생략하면 경고발생
  const int* ptr2 = (const int*) &i; // 'int*' 를 'const int*'로 형변환. 생략가능
```

## 포인터 상수
포인터를 상수로 선언하는 것도 가능하다. 포인터의 이름 앞에 'const'를 붙이기만 하면 되며, 이를 '포인터 상수' 라고 한다.

```
  int i = 100;
  int* const ptr = &i; // 포인터 상수 ptr 선언
```

포인터가 상수이면, 포인터에 저장된 주소를 변경할 수 없으므로 포인터가 다른 대상을 가리킬 수 없게 된다.

```c
  int i = 100;
  int i2 = 100;
  int* const ptr = &i; // 포인터 상수 ptr 선언

  *ptr = 200;
  // ptr++; // 에러. 포인터가 상수이므로 포인터의 값은 변경불가.
  // ptr = &i2; // 에러. 포인터에 다른 대상의 주소를 저장할 수 없음
```

포인터 상수가 가리키는 대상이 상수인 경우, 포인터 상수의 타입에 'const' 를 두번 사용해야 한다.

```c
  int i = 100;
  const int* ptr = &i; // 포인터 ptr1 이 가리키는 대상이 상수
  int* const ptr2 = &i; // 포인터 ptr2 가 상수
  const int* const ptr3 = &i; // 둘다 상수
```

주의 해야할 점은 'int* const' 와 'int const*' 가 다르다는 것이다. 'int const*' 는 'const int*' 와 같다.

```
  int i = 100;
  int* const ptr = &i; // 포인터 ptr 이 상수
  int const* ptr = &i; // cosnt int* ptr; 과 동일. ptr 의 대상이 상수
  int const *ptr = &i; // cosnt int* ptr; 과 동일. ptr 의 대상이 상수
```

'const ptr' 은 ptr 이 상수라는 것을 의미하는데 'int const* ptr'의 경우, 포인터가 가리키는 대상인 '*ptr'이 'int const' 즉 'int 타입의 상수'라는 뜻이기 때문이다.


## 포인터와 배열
포인터로 변수뿐만 아니라 배열도 다룰 수 있다. 

```
int arr[4] = {0,1,2,3};


0x100 : 0 (arr[0]) [4byte]
0x101 : 1 (arr[1]) [4byte]
0x102 : 2 (arr[2]) [4byte]
0x103 : 3 (arr[3]) [4byte]
```

위에서는 배열이 저장된 주소를 0x100번지로 가정했으며, 각 요소는 0x100번지부터 연속적으로 위치하게 된다.
배열 요소의 타입이 int 이고, int의 크기가 4 byte 이므로 인접한 두 배열요소의 간격은 4byte 이다.

포인터로 배열을 다룬다는 것은 포인터로 배열의 각 요소에 접근하는 것이므로 포인터의 대상타입은 배열요소의 타입과 일치해야한다. 그래서 int 배열을 가리키기 위한 포인터의 타입은, int 타입의 변수를 가리키는 포인터처럼 'int*' 이어야 한다.

```
  int arr[4] = {0,1,2,3};
  int *ptr = &arr[0]; // 첫번째 요소의 주소를 ptr 에 저장

  printf("*ptr : %d , ptr : %p\n" , *ptr , ptr);
  printf("arr[0] : %d , arr[0] : %p\n" , arr[0] , &arr[0]);
  printf("arr[1] : %d , arr[1] : %p\n" , arr[1] , &arr[1]);
  printf("arr[2] : %d , arr[2] : %p\n" , arr[2] , &arr[2]);
  printf("arr[3] : %d , arr[3] : %p\n" , arr[3] , &arr[3]);

/*
*ptr : 0 , ptr : 000000000061FE00
arr[0] : 0 , arr[0] : 000000000061FE00
arr[1] : 1 , arr[1] : 000000000061FE04
arr[2] : 2 , arr[2] : 000000000061FE08
arr[3] : 3 , arr[3] : 000000000061FE0C
*/
```

인접한 두 배열요소의 주소는 4가 차이난 다는 것을 눈여겨볼 부분이다

## 포인터 연산
포인터에 저장된 값은 부호없는 정수 (unsigend int) 이기 때문에 정수처럼 덧셈이나 뺄셈은 물론이고 증감연산이나 비교연산도 가능하다.

### [ 포인터와 증감연산자 ++ , -- ]
메모리에서 무조건 1바이트씩 이동하면서 값에 접근하는 것 보다 포인터의 타입에 따라 다르게 이동하면서 값을 읽어오는것이 더 유용하기 때문에 포인터의 대상의 크기에 따라 증가되는 값이 달라지도록 되어있다.

> 포인터 ptr 의 대상타입의 크기만큼 주소값이 증가한다.

이 특성은 포인터의 대상이 배열일 때 특히 유용하다. 배열요소 중 하나를 가리키고 있는 포인터의 값을 1 증가시키면 그 다음 배열요소를, 1 감소시키면 이전 배열요소를 가리키게 된다. 그래서 포인터에 배열의 첫 번째 요소의 주소를 저장한 다음 계속 증가시켜나가면서 *연산자를 함께 하용하면 배열의 모든 요소를 읽어 올 수 있다.

```c
  char* pc = (char*) 0x100;
  short* ps = (short*) 0x100;
  int* pi = (int*) 0x100;

  printf("pc : 0x%x , ps : 0x%x , pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);

/*
pc : 0x100 , ps : 0x100 , pi : 0x100
pc : 0x101 , ps : 0x102 ,pi : 0x104
pc : 0x102 , ps : 0x104 ,pi : 0x108
pc : 0x103 , ps : 0x106 ,pi : 0x10c
pc : 0x104 , ps : 0x108 ,pi : 0x110
*/
```

### *ptr++ 은 *(ptr++)? (*ptr)++?
'*ptr++' 은 포인터에서 자주 사용되는 중요한 식이다. '*' 와 '++' 모두 단항 연산자인데 어느 쪽이 더 우선순위가 높을까?

그렇다면 '*++ptr'의 경우는? 단항 연산자는 피연산자와 가까운 쪽부터 수행되니까 '++' 연산이 먼저 수행된다. 그래서 '*ptr++' 의 경우에서도 '++' 연산이 먼저 수행된다고 생각하면 기억하기 쉽다. 

그러면 '*ptr++' 이 '*(ptr++)'과 같다는 얘긴데, '++' 이 후위형이라서 헷갈리게 된다. 실제로는 '++'이 우선순위가 높지만, 후위형이라서 '*' 연산이 먼저 수행된다. 그래서 먼저 ptr 에 저장된 값을 가져온 다음에 ptr 의 값이 증가한다.

> *ptr++ == 값을 가져온 다음 ptr 의 값이 증가함

앞으로 '(*ptr)++' 보다는 '*ptr++' 을 더 자주 사용하게 될 것이다.

## 포인터의 덧셈과 뺄셈
포인터에 저장도니 값은 '부호없는 정수' 이므로, 이 값에 정수를 더하거나 빼는 것이 가능하다. 단지 좀 전에 배운것 처럼 일반적인 정수연산과 달리 포인터가 가리키는 대상의 타입에 따라 포인터의 값이 다르게 변한다.

포인터에 정수 n을 더하면, 실제로는 포인터의 값에 'n * sizeof(*ptr)' 을 더한것과 같은 결과를 얻는다.

```
ptr + 3 = 0x100 + (3 * sizeof(int))

0x100 + 12 = 0x10c
```

이번엔 뺄셈을 해보자 다음코드에서 변수 diff 에 저장되는 값은 얼마인가

```c
int arr[4];

int diff = &arr[2] - & arr[0]; 
```

'2 * sizeof(int)' 의 결과인 8을 예상했을 수도 있지만, 답은 2이다. 실제 주소값의 차이인 8을 얻고자 한다면 다음과 같이 'char*' 또는 'unsigned' 로 형변환 후에 뺄셈을 해야한다.

```c
int arr[4];
long long diff = &arr[2] - &arr[0];                       // diff 의 값은 2
long long diff = (char*) &arr[2] - (char*) &arr[0];       // diff 의 값은 8
long long diff = (unsigned) &arr[2] - (unsigned) &arr[0]; // diff 의 값은 8
```

형변환할 때 양쪽을 모두 같은 타입으로 형변환해야한다. 당연한 얘기지만 포인터의 뺄셈은 같은 타입만 가능하기 때문이다. 그리고 포인터의 값은 부호없는 정수이지만, 뺄셈의 결과는 음수일 수 있기때문에 변수 diff 의 타입을 부호있는 정수로 해야한다.

그러나 앞서 포인터의 형변환에서 언급한 것과 같이 이식성 문제가 발생할 수 있으므로 변수 diff 의 타입을 밑과 같이 'intptr_t'라는 부호있는 정수 타입으로 하는 것이 좋다. 이 타입을 사용하면 32 bit OS 나 64 bit OS 어느쪽에서나 코드의 변경없이 잘 동작한다.

> long long diff = &arr[2] - &arr[0] --> intptr_t diff = &arr[2] - &arr[0]



## void 포인터와 NULL
포인터는 메모리에 저장된 대상을 가리키기 위한 것이며, 어떤 대상을 가리키느냐에 따라서 포인터의 타입이 결정된다. 그런데 가리키는 대상의 타입이 없는 포인터도 있으며, 이를 'void 포인터' 라고 한다. void 포인터의 타입은 'void*' 이며 다음과 같이 선언한다.

> void* vp;

포인터 타입이 'void*' 이지만, 이 포인터가 가리키는 대상의 타입이 'void' 인것은 아니다. 여기서 'void' 의 의미는 타입이 정해져있지 않음을 의미할 뿐이다.
그래서 void 포인터에는 어떤 종류의 포인터의 값도 형변환 없이 대입이 가능하다.

```c
  char* pc;
  int* pi;

  void* vp1 = pc; // char* 타입의 포인터 pc의 값을 vp1 에 저장
  void* vp2 = pi; // int* 타입의 포인터 pi의 값을 vp2 에 저장
```

이처럼 대입 연산자로 void 포인터에 주소를 저장할 수는 있지만, 대상 타입이 없으므로 저장된 값만 비교하는 연산을 제외한 모든 포인터 관련 연산이 불가능 하다.

```c
  printf("%d\n" , vp1 == vp2); // void 포인터의 값만 비교하는 것은 가능
  printf("%d\n" , *vp2); // 에러
  printf("%p\n" , vp1++); // 에러
  printf("%p\n" , vp1 + 1); // 에러
  printf("%d\n" , vp1 - vp2); // 에러
```

그러면 결국 void 포인터는 결국 메모리의 주소를 저장하는 것 외에 할 수 있는 일이 없을까? 예를 들어 void 포인터로 배열을 만들면 void 포인터는 어떤 포인터의 값도 저장할 수 있으므로 void 포인터 배열에는 서로 다른 종류의 포인터를 하나의 배열로 다룰 수 있다.

```c
  char c;
  int i;
  void* vpArr[5];

  vpArr[0] = &c;
  vpArr[1] = &i;
```

이 배열에 저장된 포인터를 다시 꺼낼 때는 다시 원래의 타입으로 형변환해야 '*' 연산과 같은 포인터 관련 연산이 가능하다.

또 한가지 예는 함수의 매개변수로 사용되는 경우이다. memcmp() 의 선언부를 보자

> int memcmp(const void* v1 , const void* v2 , size_t count); // 메모리 비교 함수

이 함수가 하는 일은 지정된 두 주소에 저장된 값을 있는 그대로 비교하는 것이기 때문에 저장된 값의 타입과 상관없이 그저 주소값만 알면된다. 그래서 매개변수의 타입이 'void*' 인 것이다. 그리고 'void*' 타입의 매개변수에는 모든 포인터 타입이 형변환 없이 대입될 수 있다.

```c

  char c = 10;
  int i = 20;

  char *pc = &c;
  int *pi = &i;
  void *vp1, *vp2;

  vp1 = pc; // vp1 = (void*) pc;
  vp2 = pi; // vp2 = (void*) pi;

  printf("vp1 = %p\n", vp1);
  printf("vp2 = %p\n", vp2);
  printf("*(int*) vp2 : %d \n", *(int *)vp2);
  char *temp_vp1 = (char *)vp1;
  printf("((char*) vp1)++ : %p\n", ++temp_vp1);
  printf("(char*) vp1 + 1 : %p \n", (char *)vp1 + 1);
  printf("(char*) vp1 = (char*) vp2 : %d \n", (char *)vp1 - (char *)vp2);
  printf("vp1 = %p\n", vp1);
  printf("vp2 = %p\n", vp2);
  
/*
vp1 = 000000000061FDF7
vp2 = 000000000061FDF0
*(int*) vp2 : 20
((char*) vp1)++ : 000000000061FDF8
(char*) vp1 + 1 : 000000000061FDF8
(char*) vp1 = (char*) vp2 : 7
vp1 = 000000000061FDF7
vp2 = 000000000061FDF0
*/
```


## 더블 VOID 포인터
void 포인터를 가리키는 포인터를 '더블 void 포인터'라고 하며, 이 포인터의 타입은 'void**' 이다.

```c
int i = 100;
void* vp = &i;
void** vpp = &vp; // 더블 void 포인터 vpp 는 void 포인터 vp 를 가리키게 된다.
```

void 포인터와 달리 더블 void 포인터는 가리키는 대상의 타입이 'void*' 이다. void 라는 타입은 없지만 'void*'라는 타입은 분명히 존재하며, 이 타입의 크기는 모든 포인터의 크기와 같은 4 byte(32 bit OS 인 경우) 이다.

그래서 void 포인터와 달리 더블 void 포인터는 '*' 연산을 비롯한 포인터 관련 연산이 모두 가능하다.


## NULL 과 널 포인터
NULL 은 포인터를 초기화하는데 사용하는 상수로, 어떤 포인터의 같이 NULL 이면 이 포인터는 어떠한 대상도 가리키고 있지 않다는 것을 의미한다. 그리고 같이 NULL 인 포인터를 '널 포인터(NULL pointer)' 라고 한다.

> #define NULL (void*) 0 // NULL 은 타입이 'void*' 인 0

대부분의 컴파일러에는 위와 같이 NULL이 0으로 정의되어 있으므로 NULL 대신 0을 사용할 수도 있지만, 표준에 NULL 을 꼭 0으로 정의해야한다는 규칙이 없으므로 NULl 대신 0을 사용하는 것은 이식성을 떨어뜨리낟.

> int* ptr = NULL; // 포인터 ptr 를 NULL 로 초기화

NULL 은 위와 같이 포인터를 초기화할 때나, 특정 포인터의 값이 NULL 인지 확인하는 데 사용된다. malloc()과 같이 주소를 반환하는 함수는 문제가 발생하면 NULL 을 반환하는 데, 이런 함수를 호출한 다음에는 if 문으로 호출결과가 NULL 인지를 확인해야한다.


## 포인터와 다차원 배열
### 포인터와 2차원 배열
2차원 배열은 여러개의 1차원 배열로 이루어져있으므로, 2차원 배열은 배열요소가 1차원 배열인 1차원 배열이기도 하다. 그래서 예시로 4행 3열 2차원 int 배열 score 는 배열요소의 타입이 'int[3]' 이고 길이가 4인 1차원 배열이라고 할 수 있다.

```
[ 1 ]
int score [4][3]

score[0] int int int
score[1] int int int
score[2] int int int
score[3] int int int

[ 2 ]
포인터 2차원 배열
score[0] int[3]
score[1] int[3]
score[2] int[3]
score[3] int[3]
```

배열요소의 타입이 int[3] 이고 길이가 4인 배열을 코드로 표현하면 아래와 같으나 이런 표현은 허용되지 않는다.

> int[3] score[4]; // 허용되지 않는 표현

배열을 가리키는 포인터의 타입은 배열요소의 타입에 '*'을 붙이면 된다. 2차원 배열 score 의 배열요소 타입은 'int[3]' 이므로 이 배열을 가리키는 포인터 타입은 'int[3]*' 이어야 한다.

타입에서 배열을 의미하는 기호 '[]'는 제일 오른쪽에 와야하는데 'int[3]'을 가리키는 포인터의 타입은 'int[3]*' 이 아닌 'int(*)[3]' 이 된다.

```
int score[4][3];
int (*ptr)[3] = score; // 포인터 ptr의 타입은 'int(*)[3]'
```

typedef 를 이용하서 'int[3]을 int3'으로 정의하면 비슷하게 흉내낼 수 있긴 하다. 타입이 복잡할 때는 이처럼 타입의 일부를 재정의해서 간단히 하면 이해에 도움이 된다.

```c
typedef int int3[3]; // int[3] 을 int3 으로 정의

int3 score[4] // int score[4][3]
int3 *p = score; // int (*p)[3] = score;
```

```c
  int score[4][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};
  int(*ptr)[3] = score; // 배열의 주소를 포인터 ptr 에 저장

  int i , j;

  printf("ptr : %p\n" , ptr);
  printf("*ptr : %p\n" , *ptr);
  printf("score : %p\n" , score);
  printf("*score : %p\n" , *score);
  printf("score[0] : %p\n" , score[0]);
  printf("&score[0][0] : %p\n" , &score[0][0]);

  printf("sizeof(ptr) : %d\n" , sizeof(ptr));
  printf("sizeof(*ptr) : %d\n" , sizeof(*ptr));
  printf("sizeof(*score) : %d\n" , sizeof(*score));
  printf("sizeof(score[0]) : %d\n" , sizeof(score[0]));
  printf("sizeof(score[0][0]) : %d\n" , sizeof(score[0][0]));
  printf("sizeof(&score[0][0]) : %d\n" , sizeof(&score[0][0]));

  for(i = 0; i < 4; i++)
  for(j =0; j < 3; j++) 
  printf("score[%d][%d] : %2d , ptr[%d][%d] : %2d\n" , i , j , score[i][j] , i , j , ptr[i][j]);

/*
ptr : 000000000061FDE0          // 포인터의 값
*ptr : 000000000061FDE0         // 포인터가 가리키는 대상배열의 첫 행
score : 000000000061FDE0        // 배열의 주소
*score : 000000000061FDE0       // 첫 행의 주소
score[0] : 000000000061FDE0     // 첫 행의 주소
&score[0][0] : 000000000061FDE0 // 첫번째 요소의 주소
sizeof(ptr) : 8                 // 64 bit OS 이므로 8byte
sizeof(*ptr) : 12               // 포인터가 가리키는 대상의 크기 (한 행의 크기)
sizeof(*score) : 12             // 배열의 크기
sizeof(score[0]) : 12           // 한 행의 크기
sizeof(score[0][0]) : 4          // 한 요소의 크기
sizeof(&score[0][0]) : 8         // 한 요소의 주소의 크기
score[0][0] :  1 , ptr[0][0] :  1
score[0][1] :  2 , ptr[0][1] :  2
score[0][2] :  3 , ptr[0][2] :  3
score[1][0] :  4 , ptr[1][0] :  4
score[1][1] :  5 , ptr[1][1] :  5
score[1][2] :  6 , ptr[1][2] :  6
score[2][0] :  7 , ptr[2][0] :  7
score[2][1] :  8 , ptr[2][1] :  8
score[2][2] :  9 , ptr[2][2] :  9
score[3][0] : 10 , ptr[3][0] : 10
score[3][1] : 11 , ptr[3][1] : 11
score[3][2] : 12 , ptr[3][2] : 12
*/
```

포인터를 배열의 주소로 초기화했기 때문에 배열이름 대신 포인터를 사용해도 배열의 모든 요소에 접근할 수있다.

> score[i][j] == ptr[i][j];

```
배열의 주소 == 첫번째 행의 주소 == 첫번째 요소의 주소
score == score[0] == &score[0][0] == 0x0019FBD0
```

실행결과에서 알 수 있듯이 2차원 배열의 주소 (score), 첫 행의 주소 score[0] , 첫번째 요소의 주소 (&score[0][0]) 의 값은 모두 같다. 그러나 서로 타입이 다르다. 그래서 sizeof 연산의 결과가 서로 다른것이다.

지금까지 주로 선언문에서 이름을 빼는 방법으로 타입을 알아냈는데, 기호의 위치를 이동해서 타입을 알아낼 수도 있다. 다차원 배열에서 오른쪽 끝의 '[]' 기호를 타입쪽으로 하나씩 옮기면 된다.

```
int score[4][3]; // score [i][j] 의 타입은 int
int[3] score[4]; // score[i]의 타입은 'int[3]'
int[4][3] score; // score 의 타입은 'int[4][3]'
```

또 아래와 같이 '[]' 연산자를 적용해서 알아낼 수도 있다. 앞서 배운것 처럼 '[]' 연산자는 피연산자의 타입에서 '*' 또는 '[]'를 제거한다.

```
타입 : int[4][3] score

score (int[4][3]) -- [0] --> score[0] (int[3]) -- [0] --> score[0][0] (int)
```

한가지 주의할 점은 '[]' 연산자는 피연산자의 타입이 다차원배열일 때, 타입에서 왼쪽의 끝 '[]'부터 제거한다는 것이다. 그래서 score[0]의 타입이 'int[4][3]'에서 [4]가 제거되어 'int[3]' 이 되었다.


## '*' 연산의 결과가 주소?
앞서 배운것과 같이 '[0]' 은 '*' 과 동등하므로 'score[0]' 와 '*score' 은 값과 타입이 모두 일치한다.

> score == score[0] == *score == 0x0019FBD0

그런데 score 의 값이 '0x0019FBD0' 인데, 왜 '*score'의 값도 '0x0019FBD0' 일까? 배열의 주소인 score '*' 연산을 수행한 결과가 값이 아닌 주소라는 것인데 어떻게 이런것일까? '*' 연산자는 연산결과의 타입이 배열일 경우, 배열의 주소를 반환하기 때문이다.

> '*' 와 '[]' 연산자는 연산의 결과타입이 배열일 때, 배열의 주소를 반환한다.

지금까지 '*' 연산자는 지정된 주소에 저장된 값을 반환해왔지만 항상 그런것이 아닌 피연산자의 타입에 따라 값을 반환하기도 하고 주소를 반환하기도 하는 것이다.

```
타입 : int[4][3]
변수명 : score

[ 1 ]
score -- (*) --> *score (int[3]) ---> *0x0019FBD0 --> 0x0019FBD0 (int[3])

[ 2 ]
score[0] (int[3]) --(*)--> *score[0] (int) ---> *0x0019FBD0 --> 1
```

아래 그림에서 포인터 ptr 이 가리키고 있는 것은 배열 score 의 첫번째 행인 score[0]이므로, '*ptr' 은 score[0]에 저장된 것을 가져와야 하는데 , score[0]에 저장된 것이 배열이라서 배열 전체를 가져올 수는 없으니까 배열의 주소만 가져오는 것이다.

예제를 통해 확인해 보자

```c
  int arr[1][1] = {100};

  printf("arr : %p\n" , arr);
  printf("arr[0] : %p\n" , arr[0]);
  printf("&arr[0][0] : %p\n" , &arr[0][0]);
  printf("arr[0][0] : %d\n" , arr[0][0]);
  printf("*arr : %p\n" , *arr);
  printf("*(int*)arr : %d\n" , *(int*)arr);
  printf("**arr : %d\n" , **arr);

/*
arr : 000000000061FE1C
arr[0] : 000000000061FE1C
&arr[0][0] : 000000000061FE1C
arr[0][0] : 100
*arr : 000000000061FE1C
*(int*)arr : 100
**arr : 100
*/
```

'*' 연산의 결과타입이 배열일때, 해당 주소에 저장된 값이 아닌 주소를 반환하며 아래와 같이 1행 1열의 2차원 배열 arr 를 선언하면 이 배열은 단 하나의 요소 arr[0][0]밖에 갖지 못한다.

배열의 주소 arr의 값이 '000000000061FE1C' 인데도 '*arr' 의 결과가 100이 아닌 '000000000061FE1C' 인 이유는 앞서 설명한 것과 같이 '*' 연산의 결과타입이 배열이기 때문이다.

'*arr' 의 연산 결과는 '000000000061FE1C' 이고, 이 값의 타입은 'int[i]' 이다.

저장공간이 하나뿐인데도 배열이라서 이런 결과를 얻는다. arr을 'int*'로 형변환후에 '*' 연산을 수행하면 해당 주소에 저장된 값을 결과로 얻는다. 연산의 결과 타입이 배열이 아니기 때문이다.

> *(int*)arr --> 000000000061FE1C --> 100

'*arr' 와 '*(int*)arr' 모두 000000000061FE1C 번지에 '*' 연산을 수행하는 것이지만 피연산자의 타입에 따라 다른 결과를 반환한다. 그래서 '*' 연산을 수행할 때는 피연산자의 값뿐만아니라 연산의 결과타입에도 관심을 가져야 한다.

## 2차원 배열과 포인터 연산
다음과 같이 2차원 배열 arr과 이를 가리키는 포인터 ptr 이 선언되어 있을때, 포인터의 타입은 'int(*)[4]'이고 포인터가 가리키는 대상의 타입은 'int[4]' 이다.

```
int arr[3][4];
int (*ptr)[4] = arr // ptr 은 배열 arr의 첫행 (int[4])를 가리킨다.

주소   : 0x100
변수명 : ptr 
arr[0] : int[4] : 0x100 // 이곳을 가리킨다.
arr[1] : int[4] : 0x110
arr[2] : int[4] : 0x120

ptr 의 타입      : int(*)[4]
ptr 의 대상 타입 : int[4]
```

앞서 배운것과 같이 포인터의 값을 1증가 시키면 포인터가 가리키는 대상의 타입의 크기만큼 포인터의 값이 증가한다

> 포인터 + i == 포인터의 값 + i * sizeof(포인터의 대상타입)

만일 배열 arr 이 주소가 '0x100' 이라면, 'ptr + 1' 의 연산과정은 다음과 같다

```
ptr + 1

> 0x100 + 1 * sizeof(int[4])
> 0x100 + sizeof(int) * 4
> 0x100 + 16
> 0x110 // 16 은 0x10 이므로 0x100 + 0x10 = 0x110
```

ptr 이 2차원 배열 arr 의 첫번째 행을 가리키므로, 'ptr + 1'은 두번째 행을 가리키게 된다. '*(ptr + 1)' 은 두 번째 행에 저장된 값을 반환하는데, 두 번째 행에 1차원 배열이 저장되어 있으므로 이 배열의 주소가 반환된다.

```
주소   : 0x100
변수명 : ptr 

+ 1

arr[0] : int[4] : 0x100 
arr[1] : int[4] : 0x110 // 이곳을 가리킨다.
arr[2] : int[4] : 0x120
```

'arr+1' 도 'ptr+1' 처럼 2차원 배열의 arr의 두번째 행을 가리킨다. ptr 과 달리 arr의 타입은 'int[3][4]' 이지만 덧셈 연산이 수행되는 과정에서 자동적으로 'int(*)[4]'로 자동 형변환된다. 이것은 1차원배열의 덧셈 연산에서 'int[4]'타입이 'int*' 타입으로 자동 형변환되는 것과 같은 이치이다.

> arr + 1 -- (*) --> *(arr+1) == arr[1] == 0x110

arr 과 ptr 의 타입은 다르지만, 'arr+1' 과 'ptr+1'은 값과 타입이 모두 일치한다.

```
sizeof(arr) --> sizeof(int[3][4]) --> sizeof(int) * 3 * 4 --> 48
sizeof(ptr) --> sizeof(int(*)[4]) --> 4
sizeof(arr+1) --> sizeof(int(*)[4]) --> 4
sizeof(ptr+1) --> sizeof(int(*)[4]) --> 4
```

ptr[0] , ptr[1] , ptr[2]는 2차원 배열 arr의 한 행이며, ptr[1]은 두번째 행이다. 그러면 'ptr[1]+2'의 연산결과는 무엇일까? 세번째 요소를 가리킬 것 같다. 그런지 확인해보자

> ptr[1] + 2 --> 0x110 + 2 * sizeof(int) --> 0x118

ptr[1]의 타입은 'int[4]'인데 덧셈연산 과정에서 'int*'로 타입이 자동형변환된다. 그리고 2를 더하지만, ptr[1]의 대상타입이 'int'이므로 ptr[1]의 값인 '0x100'에 2가 아닌 '2 * sizeof(int) == 8' 이 더해져서 '0x118'을 결과로 얻는다. '0x118'은 2차원 배열 arr의 두번째 행의 세번째 요소인 'arr[1][2]'의 주소이다.

그러면 '*(ptr[1] + 2)'의 결과는 arr[1][2]가 되어야 하는데 학인해보자

> ptr[1] + 2 --> *(ptr[1] + 2) == ptr[1][2] == arr[1][2]

따라서

> ptr[i][j] == *(ptr[i] + j) == (*(ptr+i)) [j] == *(*(ptr+i) + j)

위 식에서 i 와 j가 모두 0인 경우 '[0]'은 '*'로 대체할 수 있다.

```
ptr[0] == *ptr;
ptr[0][0] == **ptr;
```

한가지 주의해야 할 점은 'ptr[0][1]' 이 '*ptr[1]'과 같지 않다는 것이다. '*' 연산자보다 '[]' 연산자의 우선순위가 높기 때문에 괄호가 필요하다.

```
ptr[0][1] == (ptr[0])[1] == (*ptr)[1]            // 괄호 생략 불가
ptr[1][0] == (ptr[1])[0] == (*ptr)[1] == *ptr[1] // 괄호 생략 가능
```

포인터에 '*' 연산과 '&' 연산을 순차적으로 적용하면 어떻게 될까? '*' 연산자로 포인터에 저장된 값을 얻을 다음에 다시 '&' 연산자로 주소를 얻어오는 것이니까 연산하기 전과 같다.

따라서 

> ptr[1] + 2 == &*(ptr[1] + 2) == &ptr[1][2]

위의 식을 통해 'ptr[1] + 2'가 '&ptr[1][2]'과 같다는 것을 알 수 있고 '&ptr[1][2]'는 ptr[1][2] 의 주소라는 것을 쉽게 파악할 수 있다. 그리고 피연산자가 배열일 때는 '&*' 연산 후에 타입이 달라진다는 것에 주의하자


## 포인터 연산의 우선순위

1. 단항 연산자는 피연산자와 가까운 쪽에서 먼 쪽의 순서로 진행한다.
```
*++ptr == *(++ptr)
++*ptr == ++(*ptr)
*&ptr == *(&ptr)
arr[i][j] == (arr[i])[j]
```

2. 단항 연산자가 양쪽에 있을 때는 오른쪽이 우선한다.
```
*ptr++ == *(ptr++)
&arr[1] == &(arr[1])
*arr[1] == *(arr[1])
```

## 2차원 배열과 1차원 배열 포인터
1차원 배열을 위한 포인터로 2차원 배열을 가리키게 하면 2차원 배열을 1차원 배열처럼 다룰 수 있다.

```
int arr[3][4];
int* p1 = (int*)arr; // 포인터의 타입에 맞게 형변환해야한다.
```

굳이 2차원 배열을 1차원 배열 포인터로 다루는 이유는 효율때문이다. 아래의 코드는 2차원 배열 arr의 모든 요소의 합을 구하는 것인데, 보통은 2차원 배열 포인터에 2중 반복문이 필요하지만, 1차원 배열 포인터를 사용하면 하나의 반복문만으로 처리가 가능하므로 효율적이다.

```
int len = sizeof(arr) / sizeof(arr[0][0]) // (3 * 4 * 4) / 4 == 12
int sum = 0;

while(len--)
  sum ++ p1++;
```

위의 코드는 2차원 배열 arr의 모든 요소의 값을 더하는 일을 하는데 이처럼 2차원 배열의 모든 요소를 순차적으로 접근하는 경우에는 1차원 배열 포인터로 2차원 배열을 다루는 것이 더 효율적이다.

다음은 1차원 배열 포인터를 이용해서 2차원 배열의 내용을 1차원 배열로 복사하는 예제다.

```c
int arr2[3][4] = { 0 , 1 , 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11};
int arr[sizeof(arr2) / sizeof(arr2[0][0])]

const int LEN = sizeof(arr2) / sizeof(arr2[0][0])
int len = LEN;
int i;

int *ptr = arr;
int *ptr2 = (int*)arr2;

while(len--)
  *ptr++ = *ptr2++;
```

반대로 1차원 배열을 2차원 배열의 포인터로 다루는 방법이다.

```c
int arr[] = { 0 , 1 , 2, 3, 4, 5, 6, 7, 8, 9, 10 ,11 , 12};
int *p1 = arr;
int (*p2)[2] = (int(*)[2])arr;
int (*p3)[3] = (int(*)[3])arr;

for(i = 0; i < 12; i++) {
  printf("p1 + %d = %p , *(p1 + %d) = %d\n" , i , p1 + i , i , *(p1 + i));
}

...
```


### 3차원 배열 과 포인터는 패스하겠다.

## 연산자 & , * , [] 비교
지금까지의 정리를 해보자

|연산자|*,[]|&|
|*--*|*--*|*--*|
|피연산자| 주소 (배열이름 , 포인터) | 주소(배열이름 , 포인터) , 저장공간 (변수)|
|결과값| '주소에 저장된 값' 또는 주소(결과타입이 배열일때)|주소|
|결과타입|포인터일 때는 '*' 제거 , 배열일 때는 '[]'를 제거|피연산자의 타입에 '*' 추가|

### & 연산자
& 연산자는 피연산자로 변수뿐만 아니라 주소(배열이름)도 가능하며, 그 결과값은 주소 그대로지만 결과타입은 달라진다. ('*'가 붙는다.)

### '*' 연산자와 '[]'연산자
'*' 연산자는 피연산자(주소)에 저장된 값을 반환하지만, '*' 연산의 결과 타입이 배열일 때는 값이 아닌 주소 (배열이름)을 반환한다.

그리고 '*' 연산자는 피연산자가 포인터일 때 '*' 를 제거하고 배열일 때는 '[]'을 제거한다.

피연산자의 타입에 '[]'와 '*' 이 같이 섞여 있을 때 어떤 것을 제거해야하는 지 판단하지 쉽지 않은데 아래의 규칙을 기억하자

1. *,[]연산자는 피연산자의 타입에서 '*' 또는 '[]'를 제거한다.
2. 피연산자가 다차원의 배열인 경우, 제일 왼쪽의 '[]'를 제거한다.
3. 피연산자가 포인터일 때는 '*'를 배열일 때는 '[]'를 제거한다.

### 공식
```
주소[i] == *(주소 + i)

*&피연산자 === 피연산자

&*피연산자 == 피연산자
```

단, 피연산자가 배열인 경우 '&*피연산자 == 피연산자'가 성립되지 않을 수 있다. '*' 연산자에 의해 배열의 길이 정보를 잃을 수 있기 때문이다.


# 포인터와 문자열
## 문자 배열과 포인터
문자 배열 (char배열)은 요소의 타입이 char 인 배열이므로, 이 배열을 가리키는 포인터의 타입은 'char*' 이어야 한다.

```
char str[] = "abc";
char *ptr = str;
```

포인터로 char 배열의 내용을 출력하려면, 반복문을 이용해서 다음과 같이 하면 된다.
포인터가 가리키는 주소에 저장된 값이 널 문자 '\0'이 아닌 동안, 포인터의 값을 증가시켜가며 해당 주소에 저장된 문자를 출력한다.
```c
// while (*ptr != '\0') 도 가능
while (*ptr) {
  printf("%c" , *ptr++);
}
```

포인터 p는 char 배열의 널 문자를 ㄱ리키고 있으므로 char 배열의 주소를 빼면 char 배열에 저장된 문자열의 길이를 구할 수 있다.

## 포인터 배열 - 문자열 배열

```
char chArr[3];
char* pArr[3]; // 3개의 포인터 (char*)를 저장할 수 있는 배열 선언
```

배열의 크기는 다음과 같다.
```
sizeof(pArr)
> sizeof(char*[3])
> sizeof(char*) * 3
> 4 * 3 // 32 bit OS 인 경우
> 12
```

다음 두 개는 비슷 하게 나눌 수 있다.
```
[ 1 ]
char *p0 , *p1 , *p2
p0 = "abc";
p1 = "123";
p2 = "ABC";

[ 2 ]
char *pArr[3]
pArr[0] = "abc";
pArr[1] = "123";
pArr[2] = "ABC";
```

## 포인터 배열의 포인터
포인터 배열을 다루기 위한 포인터의 타입은 포인터 배열요소에 타입에 '*' 추가하면 된다. char* 배열을 다루기 위한 포인터 타입은 'char*'에 '*' 추가한 'char**' 이다.

```
char* strArr[] = {"abc" , "123" , "ABC"};
char** ptr = strArr; 
```

포인터가 ptr 의 값이 배열의 이름인 strArr 과 같으므로, 이제 이 포인터로도 배열의 모든 요소에 접근이 가능하다.

```
ptr == strArr -- 0x100
*ptr == ptr[0] == strArr[0] == 0x100
**ptr == ptr[0][0] == strArr[0][0] == 'a'
```

만약 포인터 배열의 끝에 NULL 을 저장해두면, 포인터 배열의 길이를 구하지 않아도 된다. 아래는 포인터 배열에 저장된 문자열을 모두 출력하는 while 문인데 조건식이 포인터 배열의 기링 없이 작성된다.

```c
char* strArr[] = {"abc" , "123" , "ABC" , NULL};
char** ptr = strArr; 

// while(*ptr != NULL)
while(*ptr) {
  printf("*p : %s , %p\n" , *p , *p);
}

ptr = strArr;
```

위의 코드에서 while 문의 'p++'에 의해 포인터 p의 값이 변경 되었기 때문에 배열의 주소인 strArr 로 p의 값을 다시 초기화 해야한다.


## 함수 호출
포인터의 주소를 전달 할때의 몇가지 예제를 보자

밑의 포인터의 주소를 전달하려면 함수 changeX의 매개변수가 포인터의 포인터, 즉 더블 포인터이어야 한다.
```c
// 컴파일 에러는 나지 않음
void changeX(char* x) {
  x = "zzz";
}

void changeX(char** x) {
  *x = "zzz";
  printf("s" , x);
}

int main(int argc, char const *argv[])
{
  char* str = "abc";

  changeX(&str);
  return 0;
}
```

### 배열 매개변수
함수를 호출할 때, 매개변수를 통해 배열을 전달하고 싶을때는 어떻게 해야할까? 매개변수의 타입을 배열로 하면 될 것같지만, 이 방법은 성능상의 이유로 금지되어 있다. 배열이 작을 때는 괜찮지만, 클 때는 배열을 복사하는데 많은 시간이 소요되기 때문이다.

대신 매개변수로 포인터를 선언해서 함수를 호출할 때 배열의 주소만 넘겨주면 호출된 함수에서 포인터를 통해 배열에 접근할 수 있으므로 배열을 복사해서 넘겨주는 것 보다 효율적이면서 메모리도 절약된다

```c
int sumArr(int* pArr) {
  // ...
  return 0;
}

int main(int argc, char const *argv[])
{
  int arr[] = {1 , 2 ,3};

  sumArr(arr);
  return 0;
}
```

특별히 매개변수의 타입이 포인터인 경우, 아래와 같이 '*' 기호 대신 '[]'를 쓰는 것이 허용된다. 매개변수가 배열을 위한 포인터라면, 아래와 같이 '[]'기호를 써서 배열의 주소를 넘겨받기 위한 것이라고 강조하는 것이 좋다.

```
void func1 (int *pArr) ---> void func1 (int pArr[])
void func2 (int (*pArr) [4]) ---> void func1 (int pArr[][4])
void func2 (int (*pArr) [3][4]) ---> void func1 (int pArr[][3][4])
```

이처럼 타입에 포함된 기호 '*' 를 '[]' 로 바꾸는 것은 오직 매개변수의 타입에서만 가능하며 다른곳에서는 이렇게 할 수 없다는 것에 주의하자 그리고 매개변수 타입이 더블 포인터와 같이 '*' 기호가 여러개인 경우에는 하나만 '[]'로 바꿀 수 있다.

> void func (int **pArr) --> void func (int *pArr[]) 

매개변수로 배열의 주소를 넘겨받았지만, 배열의 길이에 대한 정보는 어떻게 얻을 까? 늘 그래왓던 것처럼 sizeof 를 사용하면 될 것 같지만 그렇지 않다.
아쉽게도 매개변수 arr 은 배열이름처럼 보이지만 포인터이므로 'sizeof(arr)'은 포인터의 크기를 반환할 뿐 배열의 크기를 반환하지 않는다. 그래서 배열의 주소뿐만아니라 배열의 길이도 같이 제공받아야 한다.

> void func (int arr[] , int len)

## 배열을 반환하는 함수의 반환타입
만일 사용자로부터 입력받은 내용을 문자 배열에 담아 반환하는 일을 하는 함수가 있다면, 반환타입은 어떤것으로 해야할까?

매개변수에 배열을 선언할 수 없는 것처럼, 반환타입도 배열타입으로 할 수 없기에 배열을 가리키는 포인터 타입으로 해야한다.

> char* getInput(void); // 배열 포인터의 타입 허용


<br/>

## 함수 와 포인터
### 함수 포인터의 선언과 초기화
함수 포인터란 "함수의 주소를 저장하기 위한 변수" 이다. 프로그램의 실행 중에 함수가 호출되면, 해당 함수가 저장된 메모리 주소에 있는 명령들이 하나씩 차례로 실행된다.

포인터의 타입은 포인터가 가리키는 대상의 타입에 '*'를 붙인 것이므로, 함수 포인터를 선언하려면 먼저 함수 포인터가 가리키는 대상인 함수의 타입을 알아야 한다.

```
반환타입 함수이름 (매개변수 목록); // 함수의 선언문
반환타입 (매개변수 목록)           // 함수의 타입
```

따라서 밑과 같다.
```
int add(int a , int b); // 함수 add 의 타입은 'int (int,int)'
int mul(int x , int y); // 함수 mul 의 타입은 'int (int,int)'
```

함수들을 가리키기 위한 포인터의 타입은 함수 타입 (가정) 'int(int , int)' 에 '*' 를 추가하면 되는데, 기호 '*'를 추가할 위치는 반환 타입과 매개변수의 사이이다.

```c
int (*) (int , int) // 타입이 'int(int,int)'인 함수를 가리키는 포인터의 타입
int (*pf) (int , int) // 타입이 'int(int,int)'인 함수를 가리키는 포인터 pf의 선언
```

간단히 정리하면 함수 포인터의 선언은 가리키려는 함수의 선언문에서 '함수이름' 대신에 '(*포인터이름)'을 넣으면 된다.

```
반환타입 함수이름 (매개변수 목록);    // 함수의 선언
반환타입 (*포인터이름) (매개변수 목록); // 함수 포인터 선언
```

이때 한가지 주의할 점은 괄호() 넣는 것을 잊지 말아야 한다는 것이다. 괄호가 없으면 함수 포인터 선언이 아니라 반환타입이 'int*'인 함수의 선언이 되기 때문이다.

```
int (*pf) (int, int); // 함수 포인터 pf 선언
int *pf(int, int);    // 반환타입이 'int*' 인 함수 pf 선언
```

이렇게 선언된 함수 포인터 pf 가 함수 add를 가리키게 하려면, 함수 add의 주소를 pf 에 저장해야하는데, 배열의 이름이 배열의 주소인것처럼, 함수의 이름은 함수의 주소이므로 아래와 같이 pf에 함수의 이름을 저장하면 된다.

```
int add(int , int);
int (*pf) (int , int) = add; // 함수의 주소 (add)를 함수 포인터 pf 에 저장
```

함수 포인터 pf 로 함수 add 뿐만아니라, 타입이 'int(int , int)'인 함수는 모두 가리킬 수 있으며, 이것이 함수 포인터의 장점이다.

"함수 포인터의 장점은 하나의 포인터로 여러 함수를 다룰 수 있다는 것이다."

### 함수 포인터로 함수 호출
이제 함수를 호출해보자

```
int result = add(4,3);
int result = (*pf)(3,4); // 함수 포인터로 함수를 호출
```

함수 포인터에 '*' 연산을 할 때는 반드시 괄호를 같이 써야 한다. 그렇지 않으면 함수를 호출한 결과에 '*'연산이 적용된다.

> *pf(3,4) == *(pf(3,4)) // 이러면 안된다.

함수 포인터 pf 로 함수를 호출할 때는 '*'연산자를 사용하는 것이 맞지만, 함수의 이름이 함수의 주소이고 함수 포인터에 저장된 값이 함수의 주소이므로 '*' 연산자 없이 함수 포인터만으로 호출하는것도 허용된다.

```
int result = (*pf)(3,4); // 함수 포인터로 함수를 호출
int result = pf(3,4); // '*' 연산자 없이 함수 포인터만으로도 함수 호출 가능
```

함수의 타입 'int(int , int)'와 함수 포인터의 타입 'int(*)(int,int)' 가 다르기 때문에 엄밀히 따지면 아래의 코드처럼 '*" 와 '&'연산자를 사용하는것이 맞지만, 편의상 생략이 허용된다.

```c
[ 1 ]
int add(int , int);
int (*pf) (int , int) = &add;

int result = (*pf)(3,4);

[ 2 ] - 생략 버전
int add(int , int);
int (*pf) (int , int) = add;

int result = pf(3,4);
```

가볍게 사용해보자 

```c
int add (int , int);
int main(int argc, char const *argv[])
{
  int (*pf)(int , int) = add;

  int result = pf(3,4);
  printf("result : %d" , result);
  return 0;
}

int add(int a, int b) {
  return a + b;
}

/*
result : 7
*/
```


### 함수 포인터의 형변환
함수 포인터도 형변환이 가능하며, 형변환 방법도 동일하다. 앞서 등장했던 아래의 코드에서 두 번째 문장은 형변환이 생략된 것이다. 원래는 pf 와 add 타입이 서로 달라서 형변환이 필요하다.

```
int add(int , int);
int (*pf)(int , int) = add; // pf 타입은 'int(*)(int, int)' 형변환이 생략됨 

int (*pf)(int , int) = (int(*)(int , int))add; // 형변환
```

배열 타입이 배열 포인터 타입으로 자동 형변환되는 것처럼, 함수 타입도 함수 포인터 타입으로 자동 형변환된다.

```c
[ 1 ] - 배열
int arr[5];
int* pArr = arr; // 'int*' 자동 형변환

[ 2 ] - 함수
int add(int , int);
int (*pf)(int , int) = add; // 'int(*)(int , int)' 자동 형변환
```

### 함수 포인터 배열
함수 포인터도 포인터이므로 배열로 선언이 가능하다. 함수 포인터 배열을 선언하는 방법은 먼저 함수 포인터를 선언한 다음에 함수 포인터이름의 바로 오른쪽에 '[]'를 붙이면 된다.

```c
void (*ptr)(void); // 함수 포인터
void (*pfArr[5]) (void); // 함수 포인터 배열
```

함수 포인터 배열도 함수 포인터 만큼이나 선언이 복잡한데, 아래와 같이 typedef를 이용하면 함수 포인터 배열을 좀 더 간단히 표현 가능하다.

```c
typdef void FUNC_T (void); // void(void) 타입을 FUNC_T 로 정의

FUNC_T* ptr;    // 함수 포인터
FUNC_T* ptr[5]; // 함수 포인터 배열
```

이 두 함수를 가리키는 함수 포인터 pf1 , pf2는 아래의 [1] 과 같이 선언할 수 있고, 이를 함수 포인터 배열로 바꾸면 [2]와 같다.

```c
[ 1 ]
int (*pf1)(int , int) = add;
int (*pf2)(int , int ) = mul;
int result = pf1(3,5);
int result = pf2(3,5);

[ 2 ]
int (pfArr[])(int , int) = {add , mul};

int result = pfArr[0](3, 5);
int result2 = pfArr[1](3, 5);
```

함수 포인터 배열은 여러 개의 함수를 하나로 묶어서 다룰 때 유용한데 예를 들어 나중에 처리할 작업(함수)를 배열에 모아놨다가 특정 시점에 일괄적으로 호출하 수 있고, 배열에 저장된 함수 포인터의 순서를 바꿔서 함수의 호출 순서를 변경할 수 있는 등 다양하게 활용이 가능하다.


### 함수 포인터 타입의 매개변수 [ 콜백 함수 ]
매개변수를 함수포인터 타입으로 하면, 함수 내에서 매개변수를 통해 넘겨받은 함수를 호출할 수 있다. 즉, 함수의 작업에 필요한 함수를 매개변수로 제공받을 수 있다는 이야기 이다.

```c
void repeat (unsigned n , void(*pf) (void)) {

  pf(); // 함수 호출 == 콜백 함수
}
```

### 함수 포인터 타입의 반환 타입
매개변수의 타입뿐만 아니라 반환타입으로 함수 포인터 타입이 가능하다. 그냥 함수 포인터 타입을 반환 타입 자리에 써주기만 하면 될 것 같은데 그리 간단하지는 않다.

```c
void (*)(void) getFunc(void); // 타입이 'void(*)(void)' 인 포인터를 반환하는 함수??
```

만일 함수 포인터 타입인 'void(*)(void)'를 반환타입으로 하는 함수 getFunc를 선언하라면 위와 같이 하면 되지 않을까? 라고 생각하겠지만 이런 표현은 허용되지 않는다.
아래와 같이 반환타입이 함수 포인터 타입인 경우, 함수이름과 매개변수 목록을 반환 타입의 '*'이 있는 괄호 안에 넣어야한다.

```c
void (* getFunc(void)) (void);
```

위와 같이 '*' 괄호()가 여러개 섞여 있는 복잡한 선언문이 있다면, 십중팔구 바노한타입이 함수 포인터 타입인 경우이다. 이런 식의 표현이 함수 포인터를 이해하기 어렵게 만드는 가장 큰 이유이다. 다행히 아래와 같이 typedef 를 이용하면 이러한 복잡함을 줄일 수 있다.

```c
[ 1 ]
void (* getFunc(void)) (void);

[ 2 ] - typedef 사용
typedef void FUNC_T(void); // void(void) 타입을 FUNC_T로 정의

FUNC_T* getFunc(void); // void (* getFunc(void)) (void) 와 동일
```

한가지 주의점은 반환타입이 포인터가 아닌 함수타입이 되면 안된다.

```c
typedef void FUNC_T(void);

void func(void) {}

FUNC_T getFunc(void) { // 허용되지 않음
  return func;
} // 에러
```

위의 코드에서 함수 getFunc는 반환타입이 FUNC_T 이며, func 라는 함수의 주소를 반환한다. 함수 func 의 타입이 FUNC_T와 일치하므로 아무런 문제가 없어 보이지만 이러한 표현은 허용되지 않는다. 함수의 포인터를 반환할 수 있어도 함수 자체를 반환하는 것은 불가능하기 때문이다. 이것은 함수가 배열의 포인터를 반환할 수는 있어도 배열 자체를 반환할 수 없는 것과 같은 이유이다.

따라서 밑과 같이 바뀌어야 한다.

```c
[ 1 ] - 변경 전
typedef void FUNC_T(void);

void func(void) {}

FUNC_T getFunc(void) { // 허용되지 않음
  return func;
} // 에러

[ 2 ] - 변경 후
typedef void FUNC_T(void);

void func(void) {}

FUNC_T* getFunc(void) { 
  return (FUNC_T*) func; // 형변환 생략 가능
}  // OK!!
```

위와 같이 사용해보자
```c
#include <stdlib.h>
typedef void FUNC_T(void); // void(void) 타입을 FUNC_T로 정의

void f1(void)
{
  printf("f1() is called.\n");
}

void f2(void)
{
  printf("f2() is called.\n");
}

FUNC_T** makeFuncPtrArr(int size) {
  FUNC_T** fpArr = calloc(size , sizeof(FUNC_T*));
  return fpArr;
}
int main(int argc, char const *argv[])
{
  FUNC_T** fpArr = makeFuncPtrArr(3);

  fpArr[0] = f1;
  fpArr[1] = f2;
  
  while(*fpArr != NULL) {
    (*fpArr) ();
    fpArr++;
  }
  return 0;
}

/*
f1() is called.
f2() is called.
*/
```

함수 포인터 배열을 동적으로 생성하고, 초기화 한 다음에 이 배열에 저장된 모든 함수를 호출하는 예제이다. 함수 makeFUncPtrArr 은 동적 할당으로 함수 포인터 배열을 생성하고 그 주소를 반환한다. 이 함수 포인터 배열의 요소는 타입이 'void(*)(void)'이므로 배열을 가리키는 포인터의 타입은 'void(**)(void)' 이어야 한다.
