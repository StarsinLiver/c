## Pointer
포인터를 이해하기 위해서는 먼저 메모리 주소에 대해 알아보자. 메모리의 종류에는 여러가지가 있지만 여기서는 컴퓨터에 장착된 램(RAM)을 의미한다.
메모리는 물리적으로 여러 개의 칩으로 구성되어 있지만, 운영체제(OS)는 메모리를 하나의 연속된 저장공간으로 간주한다.

그리고 이 저장 공간을 1byte 단위로 나누어 0부터 시작하여 1씩 증가하는 일련번호를 붙인 것이 메모리 주소이다.

32bit OS 의 경우 한번에 다룰 수 있는 데이터의 크기가 32bit (=4byte) 이므로, 메모리에 부여할 수 있는 주소의 범위는 19진수로 '0 ~ 2의32승 - 1' , 16진수로 '0x0 ~ 0xFFFFFFFF' 가 된다. 그래서 32bit OS는 최대 4GB(2의 32승)의 메모리를 다룰 수 잇는 것이다. 아무리 많은 용량의 메모리가 장착되어 있는 64bit 컴퓨터라도 32bit OS 를 사용한다면 하나의 프로세스가 최대 4GB의 메모리 밖에 사용할 수 없다.

여기서는 이해가 쉽도록 32bit OS 를 기준으로 설명한다.

## 변수와 메모리 주소
아래의 문장이 수행되면 메모리에 int 타입의 값(4byte)을 위한 저장 공간이 마련되고 그 저장 공간에 1이 저장될 것이다.

> int i = 1; // int 타입의 변수 i 를 선언하고 1을 저장

변수 i는 메모리의 어딘가에 분명히 저장되어 있을 것이므로, 저장된 곳의 주소가 있을 것이다. 그 주소를 0x100 이라고 가정한다면

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

[ 메모리 ] == i
0x100 : 00
0x101 : 00
0x102 : 00
0x103 : 01

값 : 0x00000001
```

변수 i는 타입이 int 이므로 i 를 위한 저장공간은 메모리 주소 0x100 부터 0x103까지 모두 4byte가 필요하다. 이때 변수 i의 주소는 i가 저장된 범위의 시작주소인 0x100이다.
변수 i의 타입이 int 이므로 시작주소가 0x100 것만 알면 저장범위가 0x100 ~ 103이라는 것은 쉽게 알 수 있다. 그래서 어떤 대상의 주소는 항상 그 대상이 저장된 범위의 시작주소를 의미한다.

> "어떤 대상의 주소는 저장된 범위의 시작 주소를 의미한다."


## 포인터란?
포인터는 영어로 '무엇을 가리키다.' 라는 뜻의 동사 'point'에 명사형 어미 'er'이 붙은 것으로 '무엇을 가리키는 것' 이라는 뜻의 명사다

포인터는 메모리에 저장된 것 예를 들어 변수나 배열을 가리키기 위한 것이다. 가리킨다는 것은 포인터가 어떤 대상의 주소를 저장하고 있다는 것을 의미한다. 아래의 그림은 포인터 ptr 이 변수 i를 가리키고 있는 상황을 표현한 것으로 포인터 ptr 에 변수 i의 주소인 0x100이 저장되어있는 것을 알 수 있다.

> ptr [ 0x100 ] ----> i [ 0x100 , 값 : 1]

결국 포인터는 메모리 주소 (부호없는 정수)를 저장하기 위한 변수인 것이다. 선언하는 방법, 값을 저장하고 읽어오는 방법 모두 변수와 같다. 포인터는 메모리 주소를 저장하기 위한 것이라는 것만 다르다.

> "포인터는 메모리 주소를 저장하기 위한 변수"

변수와 마찬가지로 포인터도 const 키워드를 붙여서 상수로 만들 수 있으며 이를 '포인터 상수'라고 부른다. 포인터를 '포인터 상수'와 구분하기 위해서 '포인터 변수'라고 하는데, 꼭 필요한 경우를 제외하고 간단히 '포인터'라고 부른다.

## 포인터의 선언
포인터의 선언방법은 변수의 선언방법과 동일하다. 다만 포인터가 가리키는 대상의 타입에 '*'를 붙인다.
```
> 타입* 포인터명; // 지정된 타입의 값을 가리키기 위한 포인터 선언
> int* ptr;
```

위와 같이 포인터 ptr 를 선언했을 때 ptr 의 타입이 'int' 가 아닌 것에 주의하자.

ptr 이 가리키는 대상의 타입이 'int'이고, ptr 의 타입은 'int*' 이다. 선언문 '타입 이름;' 에서 이름을 빼고 남는 것은 바로 타입이다. 포인터 선언문 'int* ptr' 에서 포인터의 이름 ptr 을 제외하고 남는 'int*' 가 바로 ptr 의 타입이다.

포인터임을 알리는 기호 '*'는 타입 뒤에 붙여도 되고 포인터 이름 앞에 붙여도 된다. 타입과 포인터 이름 사이에 두는것도 가능하다
```c
[ 전부 가능 ]
int* ptr;
int * ptr;
int *ptr;
```
여러 포인터를 함께 선언한 때는 포인터 이름 앞에 '*' 기호를 붙이는 것이 좋다. 그렇지 않으면 의도한 것과 전혀 다른 선언이 되어 버릴 수 있다.

```c
int *ptr1 , *ptr2; // ptr1 , ptr2 모두 'int*' 타입의 포인터로 선언

int* ptr1 , ptr2; // ptr1 만 포인터로 선언됨. ptr2 의 타입은 'int'
```

주의하자

## 포인터에 주소 저장하기 - & 연산자
포인터에 주소를 저장하려면 먼저 포인터가 가리킬 대상의 주소를 얻어야하는데 그 일을 하는 것이 '&연산자(주소 연산자)' 이다.

'&'연산자는 피연산자가 하나인 단한 연산자로 '&피연산자'의 형태로 사용된다. '&'연산자는 피연산자의 주소를 반환하며, 피연산자로 변수나 배열요소처럼 저장공간을 가지고 있는 것만 허용된다.

아래의 코드는 변수 i와 포인터 ptr 을 선언하고 , &연산자로 변수 i의 주소를 얻어서 포인터 ptr 에 저장한다.
```
int i = 1;
int *ptr = &i; // 변수 i의 주소를 포인터 ptr 에 저장
```

변수 i 의 주소가 0x100 이라고 가정하면 위의 문장은 다음과 같은 과정으로 처리된다.

```
int* ptr = &i; // &연산자로 변수 i의 주소 (0x100)을 얻어온다.
int* ptr = 0x100; // 0x100을 ptr 에 저장


> ptr [ ]               i [ 0x100 , 값 : 1]
> ptr [ ]  <-- 0x100 -- i [ 0x100 , 값 : 1]
> ptr [ 0x100 ]  --->   i [ 0x100 , 값 : 1]
```

포인터 ptr 이 변수 i를 가리키고 있다는 의미로 화살표를 그려넣었으며, 이제 변수 이름인 i뿐만 아니라 포인터 ptr를 통해서도 변수 i에 접근이 가능하다.

```c

  int i = 5;
  int* p = &i;

  printf("i : %d\n" , i);
  printf("&i : %d\n" , &i);
  printf("p : %d\n" , p);
  printf("&p : %d\n" , &p);

/*
i : 5
&i : 6422044
p : 6422044
&p : 6422032
*/
```

실행할 때마다 프로그램이 메모리에 올라가는 주소가 달라지므로 매번 결과가 달라진다.

메모리주소 출력을 위한 지시자는 '%p' 이다. 주소 앞에 접두사 '0x'를 붙이고 싶으면, 지시자 '%#010x'를 사용하면 된다. '#'는 접두사 '0x'를 의미하고 '010'dms 전체 10자리 (접두사 포함) 중 빈자리는 0으로 채우라는 뜻이다.

```c
  int i = 5;

  printf("%p : %p\n" , &i);
  printf("%#010x : %#010x\n" , &i);
  printf("%#010X : %#010X\n" , &i);

/*
000000000061FE14 : 0000000000672610
0x0061fe14 : 0xd5a2e7a0
0X0061FE14 : 0XD5A2E7A0
*/
```

## 포인터로 값 읽어오기 - * 연산자
포인터가 가리키는 대상에 저장된 값을 가져올 때는 '*'연산자를 사용한다. '*' 연산자는 '간접 참조 연산자(dereference operator)' 라고 하는데, '*피연산자'의 형태로 사용되는 단항 연산자로 피연산자(포인터)가 가리키는 주소에 저장된 값을 읽어서 반환한다.

간접 참조 연산자 '*'는 곱셈 연산자와 같은 기호를 사용하지만 피연산자의 개수로 구분이 가능하다.

> '*' 연산자 (간접 참조 연산자)는 지정된 주소에 저장된 값을 반환한다.

```c
  int i = 200;
  int* ptr = &i; // i 의 주소값을 저장한다.

  printf("i : %d\n" , i);
  printf("*ptr : %d\n" , *ptr);

/*
i : 200
*ptr : 200
*/
```

위의 코드는 변수 i의 주소가 0x100라고 가정하면, '*ptr'은 '*'연산자가 피연산자인 ptr 이 가리키는 주소에 저장된 값을 가져온다.
뿐만 아니라 'i' 와 '*ptr'은 식에서도 동등한 것으로 취급된다. 즉, 변수이름인 'i' 대신 '*ptr'을 사용할 수 있는것이다.

아래의 두 코드는 동등하다.

```
[ 1 ]
int i = 200;
int* ptr = &i;
i = i + 1;

[ 2 ]
int i = 200;
int* ptr = &i;
*ptr = *ptr + 1;
```

그렇다고 해서 변수 이름 'i' 와 '*ptr' 이 완전히 동일한 것은 아니다. '*ptr'은 포인터를 통해서 간접적으로 변수에 접근하는 것이기 때문에 변수 이름으로 직접 접근하는 것에 비해 비효율적이다.

```c
  int i = 200;
  int* ptr = &i; // i 의 주소값을 저장한다.

  printf("i : %d\n" , i);
  printf("*ptr : %d\n" , *ptr);

  printf("&i : %d\n" , &i);
  printf("ptr : %d\n" , ptr);

/*
i : 200
*ptr : 200
&i : 6422036
ptr : 6422036
*/
```

## & 연산자와 * 연산자 비교
주소 연산자 '&'는 저장공간의 주소를 반환하고, 간접 참조 연산자 '*'는 주소에 저장된 값을 반환한다. 즉, 이 두연산자는 서로 반대의 일을 한다.

```
'&' 연산자의 반환값 : 저장공간 (변수)의 주소
'*' 연산자의 반환값 : 주소에 저장된 값
```

지금까지 '&' 연산자와 '*' 연산자의 연산결과값, 즉 반환값에 대해서만 얘기하고 '반환값의 타입'에 대해서는 별로 관심을 갖지 않았는데, 사실 연산자의 반환값 못지않게 중요한 것이 반환값의 타입(반환타입 , 결과타입)이다.

반환 타입에서도 두 연산자는 상반된 결과를 보인다. '&' 연산자의 반환타입은 피연산자의 타입에 '*' 을 추가한 것이고, '*'연산자는 반대로 피연산자의 타입에서 '*'를 제거한 반환타입이다. 그래서 타입에 '*'기호가 포함된것만 '*'연산자의 피연산자가 될 수 있다.

```
'&' 연산자의 반환타입 : 피연산자의 타입에 '*' 추가
'*' 연산자의 반환타입 : 피연산자의 타입에서 '*' 제거
```

아래 코드는 우변의 타입을 따져보면 좌변의 타입과 일치하는 것을 알 수 있다.

```c
[ 1 ]
  int i = 200;
  int* ptr = &i; // & 반환 타입은 * 이다.

[ 2 ]
  int tmp = *ptr; // * 반환 타입은 '*' 뺀 타입이다.
```

밑의 박스는 변수 i 와 포인터 p에 '&' 연산과 '*' 연산을 수행했을 때, 결과값과 결과 타입의 변화를 보여준다.

```
[ 1 ]
변수 : i [int] -- ( & ) --> 주소 : &i [int*] -- (*) --> 변수 : *&i [int] == i

[ 2 ]
주소 : P [int*] -- ( * ) --> 변수 : *P [int] -- (&) --> 주소 : *&P [int*] == P
```

위의 과정들을 살펴보면 '&' 연산을 수행하면 피연산자의 타입에 '*' 이 추가되고, '*'연산을 수행하면 '*'이 제거된다는 것을 알 수 있다. 그래서 포인터든 변수든 '*' 연산과 '&'연산을 동시에 적용하면 원래의 타입으로 돌아온다.


## 포인터의 타입
포인터의 타입은 포인터가 가리키는 대상의 타입에 '*'을 추가한 것이다. 만일 포인터가 가리키는 대상의 타입이 'int' 라면 이 포인터의 타입은 'int*' 이어야 한다.

> 포인터의 타입은 '포인터가 가리키는 대상의 타입에 '*'를 추가한 것

즉, 포인터의 타입은 '포인터의 대상타입'과 포인터임을 알리는 기호 '*'로 이루어지는데 포인터의 타입에 포함된 '*'는 기호일 뿐 연산자가 아니다. 그 외의 경우에 나타나는 '*'은 모두 간접참조연산자이다.

포인터의 타입에 포함된 기호 '*'가 의미하는 것은 선언대상이 '포인터' 라는 것과 간접참조연산 '*'이 가능하다는 것이며, '*' 연산자로 메모리에 저장된 값을 읽어오려면 주소만으로 부족하다. 해당 주소에서 몇 바이드를 읽어 와서 어떻게 해석할지에 대한 정보도 필요한데 이런 정보들은 '포인터의 대상타입'이 제공한다.

```
int* ptr;

포인터의 대상 타입     : int
포인터임을 알리는 기호 : *

포인터의 타입          : int*
```

만일 int 타입의 변수 i 를 포인터 ptr 이 가리키고 있다면, ptr에 저장된 값인 '0x100'이 포인터가 가리키는 값의 주소에 대한 정보를, ptr의 대상타입인 'int'가 몇 바이트를 읽어와서 어떻게 해석할 지에 대한 정보를 제공하는 것이다.

따라서 만일 포인터가 가리키는 대상의 타입이 int 라면 sizeof(int)의 결과인 4byte 만큼 읽어온다.

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 00
0x101 : 00
0x102 : 00
0x103 : 01

0 00000000 00000000 00000000 00000001
```

여기서 중요한 것은 포인터가 가리키는 주소에서 읽어온 값이 0x00000001 이라고 해서 이 값을 당연히 숫자 1이라고 생각하면 안된다는 것이다. 포인터의 타입이 'int*'이니까 int 타입의 형식으로 해석되어 1인 것이지, 만일 포인터의 타입이 'float*' 이었다면 이 값은 1이 아닌 '1.401298e-45' 로 해석되었을 것이다.


## 포인터의 형변환
포인터의 타입도 형변환이 가능하며, 형변환 방법은 기본형과 동일하다.

포인터의 타입이 의미하는 것은 '얼마만큼의 데이터를 읽어와서 어떻게 해석할 것인지'이므로, 포인터가 다른 포인터 타입으로 형변환되면 '읽어올 데이터의 양과 해석방법'이 달라질 뿐 포인터에 저장된 값(주소)에는 아무런 영향을 미치지 않는다.

그리고 같은 주소에서 '읽어올 데이터의 양과 해석방법'은 여러가지가 존재할 수 있으므로, 포인터를 다양한 포인터 타입으로 자유롭게 형변환하는 것이 허용된다.

```
  int i = 0x1B2B3B4B;
  int* pi = &i;

  char* pc = (char*) pi;
```

위와 같은 코드가 있을 때, 포인터 pi 에 저장된 주소를 포인터 pc 에 저장하면 형변환이 필요하다. 대입 연산자의 양변은 타입이 일치해야 하기 때문이다. 

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

  int i = 0x1B2B3B4B;
  int* pi = &i;

[ 1 ]
[ 메모리 ] == pi [0x100]

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

[ 2 ]
  char* pc = (char*) pi;

[ 메모리 ] == pi [0x100]

[ 메모리 ] == pc [0x100]

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

> 포인터 pi 의 값을 포인터 pc 에 형변환을 해 저장을 해도 저장된 값(주소)에는 아무런 변화가 없다.
```

이제 pi 뿐만 아니라 pc 를 이용해서도 변수 i 에 접근할 수 있다. 포인터 pi 와 pc 모두 변수 i를 가리키고 있지만, 서로 타입이 다르기 때문에 '*연산자'를 이용해서 읽어올수 있는 값의 크기가 다르다. *pi 는 4byte 를 읽어오지만, *pc 는 1byte 만 일거올다. 포인터 pc 의 대상타입이 'char(1byte)' 이기 때문이다.

```
[ 메모리 ] == pi [0x100]
pi 는 4byte 를 읽어 올수 있다. 
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

[ 메모리 ] == pc [0x100]
pc 는 1byte 를 읽어 올수 있다. 
0x100 : 1B
```

short 도 추가해보자

```c
  int i = 0x1B2B3B4B;
  int* pi = &i;

  char* pc = (char*) pi;
  short *ps = (short*)pi;

  printf("&i : %d\n" , &i);
  printf("pi : %d\n" , pi);
  printf("pc : %d\n" , pc);
  printf("ps : %d\n" , ps);

  printf("*pi : %X\n" , *pi);
  printf("*pc : %X\n" , *pc);
  printf("*ps : %X\n" , *ps);
  printf("*(int*) pc = %X\n" , *(int*) pc);

/*
&i : 6422020
pi : 6422020
pc : 6422020
ps : 6422020
*pi : 1B2B3B4B
*pc : 4B
*ps : 3B4B
*(int*) pc = 1B2B3B4B
*/
```

실행결과를 보면 예상과 달리 '*pc'의 연산결과로 '1B'가 아닌 '4B'가 출력되었는데 그 이유는 위 예제를 실행한 시스템의 CPU가 사용하는 '바이트 순서(byte order)' 가 '리틀 엔디안' 이기 때문이다. 리틀 엔디안 방식을 사용하는 CPU는 데이터를 역순으로 저장한다.

```
변수 이름 : i
변수 타입 : int
메모리 주소 : 0x100

int i = 0x1B2B3B4B;

[ 메모리 ] == i == sizeof(int) [4byte]
0x100 : 4B
0x101 : 3B
0x102 : 2B
0x103 : 1B
```

그리고, 포인터 pc 는 pi 와 같은 주소를 가리키기 때문에, pc를 'int*' 으로 형변환하기만 하면 pc 로도 pi 처럼 4byte의 데이터를 읽어 올수 있다.

## 빅엔디안과 리틀엔디안 (Big endian & Little endian)
4 byte 데이터 (0x1B2B3B4B)를 저장하면, 순서대로 저장될 수도 그렇지 않은 CPU 도 있다. 인텔 CPU는 데이터를 역순으로 저장한다.

```
[ Big endian ]
0x100 : 1B
0x101 : 2B
0x102 : 3B
0x103 : 4B

[ Little endian ]
0x100 : 4B
0x101 : 3B
0x102 : 2B
0x103 : 1B
```

사람이 읽고 쓰는 것처럼 높은 자리부터 순서대로 저장하는 방식을 '빅 엔디안 (Big endian)' 이라고 하고, 그 반대로 저장하는 방식을 '리틀 엔디안 (Little endian)' 이라고 한다. 인텔 CPU는 리틀 엔디안 방식을 사용한다.

> 포인터를 사용하려면 우선 CPU 가 어떤 방식을 사용하는 지 알아 보는 것도 중요하다.

## 포인터를 기본형으로 변환
모든 타입의 포인터에 저장된 값을 항상 '부호 없는 정수' 이므로, 포인터 타입을 기본형으로 변환할 때는 부호 없는 정수타입으로 변환하는 것이 적절하다.

```c
  int i = 1;
  int* pi = &i; // 0x100 주소로 가정 

  unsigned addr = (unsigned)pi; // 포인터 타입을 정수로 형변환 addr = 0x100
```

32 bit OS 에서는 포인터 타입과 int 타입의 크기가 모두 4 byte 이지만, 64 bit OS 에서는 포인터의 타입의 크기가 8byte 이고, int 타입의 크기는 4byte이다. 즉 위의 코드는 64 bit OS 에서 주소의 일부가 잘려서 변수 addr 에 저장될 것이다.

그래서 C언어는 포인터에 저장된 값(주소)과 동일한 크기의 부호없는 정수 타입인 'uintptr_t' 를 제공한다.

아래 코드에서 unsigned 보다 uintptr_t 로 작성하는 것이 이식성이 좋은 코드이다. 이 타입들을 사용하면 32 bit OS 나 64 bit OS 어느쪽에서도 코드의 변경없이 잘 동작할 것이다.

```c
#include <stdio.h>

int i = 1;
int* pi = &i; // 0x100 주소로 가정 

unsigned addr = (unsigned)pi; // 포인터 타입을 정수로 형변환 addr = 0x100
uintptr_t addr2 = (uintptr_t)pi; // 이식성이 좋은 코드
```

포인터 타입을 실수형으로 형변환하는 것은 금지되어 있고, 그렇게 해야 할 경우도 없을 것이다. 그래도 필요하다면 정수형으로 형변환한 다음에 실수형으로 형변환하면 된다.

```c
int* pi = (int*) 0x10; 
// float f = (float) pi; // 에러
float f2 = (float) (unsigned) pi; // OK 
```

0x100 은 10진수로 16이므로 f2 에는 16.0f 가 저장된다.

```c
  int i = 0x1B2B3B4B;
  int* pi = &i;

  unsigned addr = (unsigned) pi;

  printf("addr : %08X, *(char*) addr : %X\n" , addr , *(char*)addr);
  printf("addr+1 : %08X, *(char*) addr : %X\n" , addr+1 , *(char*) (addr + 1));
  printf("addr+2 : %08X, *(char*) addr : %X\n" , addr+2 , *(char*) (addr + 2));
  printf("addr+3 : %08X, *(char*) addr : %X\n" , addr+3 , *(char*) (addr + 3));

/*
addr : 0061FE10, *(char*) addr : 4B
addr+1 : 0061FE11, *(char*) addr : 3B
addr+2 : 0061FE12, *(char*) addr : 2B
addr+3 : 0061FE13, *(char*) addr : 1B
*/
```

변수 i 의 주소를 'unsigned' 타입의 변수 addr 에 저장한 다음, 이 변수의 값을 1씩 증가시켜가면서 간접 참조 연산자 '*' 로 1byte 씩 가져온다. 이렇게 하면 변수 i의 값을 1 byte 씩 읽어올 수 있다.

변수 addr 의 값은 포인터 pi 와 같지만, addr 의 타입은 unsigned 이므로 타입에 '*' 이 없어서 갑접 참조 연산자 '*'의 피연산자가 된 수 없다. 그래서 위와 같이 'char*'로 형변환한 다음에 '*' 연산을 수행해야 한다.

## 포인터의 포인터
포인터도 변수이므로 포인터가 포인터를 가리키는 것이 가능하다, 포인터를 가리키는 포인터를 '포인터의 포인터' 또는 '더블 포인터' 라고 한다.

포인터의 타입은 포인터가 가리키는 대상의 타입에 '*'기호를 추가한 것이므로 만일 포인터 pi의 타입이 'int*' 이라면, 포인터 pi 를 가리키는 포인터의 타입은 'int**' 이다.

```
int i = 100;
int* pi = &i;

int* pi2 = (int*) &pi; // 포인터 pi 를 가리키는 포인터
```

만일 위와 같이 포인터 pi 를 더블 포인터가 아닌 포인터 pi2 로 가리키도록 하면 , 전과 달리 포인터 pi2로 변수 i에 접근이 불가능 하다.

```c
int* pi2 [ 0x200 ] --> int* pi  [ 0x100 ] -- (pi2 접근 불가) --> i

printf("*pi2 : %#x\n" , *pi2); // *pi2 = 0x100 [*pi]
printf("**pi2 : %#x\n" , **pi2); // 에러
```

더블 포인터를 사용했을 때와 달리 포인터 pi2 로는 변수 i 에 접근할 수 없다. pi2 도 ppi 처럼 pi 의 주소를 가지고 있는데 왜 pi2 로는 i에 접근이 불가능 한 것일까?
그 이유는 단지 pi2의 타입이 적절하지 않기 때문이다.

'*' 연산자는 피연산자의 타입에서 '*'를 제거하므로 '*' 연산을 두번 수행하려면 피연산자의 타입에 '*'이 최소한 두 개가 포함되어 있어야 하는데, pi2의 타입은 'int*' 이므로 '*' 연산이 한번밖에 수행할 수 없다.

그러나 pi2 의 타입을 더블 포인터의 타입 (int**)으로 형변환하기만 하면 pi2로도 ppi 처럼 변수 i 에 접근이 가능하다.

```
**(int**) pi2;
```

## 더블 포인터의 포인터
더블 포인터를 가리키는 포인터, 즉 트리플 포인터를 선언할 수 있으며, 그 이상도 얼마든지 가능하다.

대부분의 경우 한 두개가 보통이고 많아야 세개정도인데, 타입에 '*'이 몇개가 붙어있든 모두 포인터일 뿐이다. 그저 규칙에 따라 타입계산만 잘하면 별 어려움 없이 처리가 가능하다.

```
  int i = 100;
  int* pi = &i;
  int** ppi = &pi;
  int* pi2 = (int*) &pi;

  printf("i : %d\n" , i);
  printf("&i : %p\n" , &i);
  printf("pi : %p\n" , pi);
  printf("&pi : %p\n" , &pi);
  printf("ppi : %p\n" , ppi);
  printf("*ppi : %p\n" , *ppi);
  printf("**ppi : %p\n" , **ppi);
  printf("pi2 : %p\n" , pi2);
  printf("*pi2 : %p\n" , *pi2);
  printf("**(int**)pi2 : %d\n" , **(int**)pi2);
  printf("sizeof(pi) : %d\n" , sizeof(pi));
  printf("sizeof(pi) : %d\n" , sizeof(ppi));

/*
i : 100
&i : 000000000061FE0C
pi : 000000000061FE0C
&pi : 000000000061FE00
ppi : 000000000061FE00
*ppi : 000000000061FE0C
**ppi : 0000000000000064
pi2 : 000000000061FE00
*pi2 : 000000000061FE0C
**(int**)pi2 : 100
sizeof(pi) : 8
sizeof(pi) : 8
*/
```

## 포인터 상수와 상수 포인터
const 는 원래 표준 C에 없던 것으로 C++ 에서 가져온 것이다. 필요성이 높이서 C99부터 새로 추가되었다. const 는 앞서 배운 것과 같이 상수를 선언할 때 사용된다.

> 포인터가 가리키는 대상이 상수일 때, 포인터의 타입에도 'const'가 포함 되어야 한다.

이처럼 상수를 가리키는 포인터를 '상수 포인터' 라고 한다.

```c
const int MAX = 999;
const int* ptr = &MAX;
```

포인터가 가리키는 대상이 상수가 아니어도 포인터의 타입 앞에 'const'가 붙어 있으면 포인터로 가리키는 대상의 값을 변경할 수 없게 된다.

```c
int i = 999;
const int* ptr = &i;

  // *ptr = 1; // 에러
```

타입에 'const'가 붙어있는 쪽으로 대입은 형변환이 생략가능하며, 그 반대의 경우 형변환을 생략하면 경고가 발생한다.

```c
  const int MAX = 999;
  int i = 999;

  const int* ptr = (int*) &MAX; // 'const int*' 을 'int*'로 형변환. 생략하면 경고발생
  const int* ptr2 = (const int*) &i; // 'int*' 를 'const int*'로 형변환. 생략가능
```

## 포인터 상수
포인터를 상수로 선언하는 것도 가능하다. 포인터의 이름 앞에 'const'를 붙이기만 하면 되며, 이를 '포인터 상수' 라고 한다.

```
  int i = 100;
  int* const ptr = &i; // 포인터 상수 ptr 선언
```

포인터가 상수이면, 포인터에 저장된 주소를 변경할 수 없으므로 포인터가 다른 대상을 가리킬 수 없게 된다.

```c
  int i = 100;
  int i2 = 100;
  int* const ptr = &i; // 포인터 상수 ptr 선언

  *ptr = 200;
  // ptr++; // 에러. 포인터가 상수이므로 포인터의 값은 변경불가.
  // ptr = &i2; // 에러. 포인터에 다른 대상의 주소를 저장할 수 없음
```

포인터 상수가 가리키는 대상이 상수인 경우, 포인터 상수의 타입에 'const' 를 두번 사용해야 한다.

```c
  int i = 100;
  const int* ptr = &i; // 포인터 ptr1 이 가리키는 대상이 상수
  int* const ptr2 = &i; // 포인터 ptr2 가 상수
  const int* const ptr3 = &i; // 둘다 상수
```

주의 해야할 점은 'int* const' 와 'int const*' 가 다르다는 것이다. 'int const*' 는 'const int*' 와 같다.

```
  int i = 100;
  int* const ptr = &i; // 포인터 ptr 이 상수
  int const* ptr = &i; // cosnt int* ptr; 과 동일. ptr 의 대상이 상수
  int const *ptr = &i; // cosnt int* ptr; 과 동일. ptr 의 대상이 상수
```

'const ptr' 은 ptr 이 상수라는 것을 의미하는데 'int const* ptr'의 경우, 포인터가 가리키는 대상인 '*ptr'이 'int const' 즉 'int 타입의 상수'라는 뜻이기 때문이다.


## 포인터와 배열
포인터로 변수뿐만 아니라 배열도 다룰 수 있다. 

```
int arr[4] = {0,1,2,3};


0x100 : 0 (arr[0]) [4byte]
0x101 : 1 (arr[1]) [4byte]
0x102 : 2 (arr[2]) [4byte]
0x103 : 3 (arr[3]) [4byte]
```

위에서는 배열이 저장된 주소를 0x100번지로 가정했으며, 각 요소는 0x100번지부터 연속적으로 위치하게 된다.
배열 요소의 타입이 int 이고, int의 크기가 4 byte 이므로 인접한 두 배열요소의 간격은 4byte 이다.

포인터로 배열을 다룬다는 것은 포인터로 배열의 각 요소에 접근하는 것이므로 포인터의 대상타입은 배열요소의 타입과 일치해야한다. 그래서 int 배열을 가리키기 위한 포인터의 타입은, int 타입의 변수를 가리키는 포인터처럼 'int*' 이어야 한다.

```
  int arr[4] = {0,1,2,3};
  int *ptr = &arr[0]; // 첫번째 요소의 주소를 ptr 에 저장

  printf("*ptr : %d , ptr : %p\n" , *ptr , ptr);
  printf("arr[0] : %d , arr[0] : %p\n" , arr[0] , &arr[0]);
  printf("arr[1] : %d , arr[1] : %p\n" , arr[1] , &arr[1]);
  printf("arr[2] : %d , arr[2] : %p\n" , arr[2] , &arr[2]);
  printf("arr[3] : %d , arr[3] : %p\n" , arr[3] , &arr[3]);

/*
*ptr : 0 , ptr : 000000000061FE00
arr[0] : 0 , arr[0] : 000000000061FE00
arr[1] : 1 , arr[1] : 000000000061FE04
arr[2] : 2 , arr[2] : 000000000061FE08
arr[3] : 3 , arr[3] : 000000000061FE0C
*/
```

인접한 두 배열요소의 주소는 4가 차이난 다는 것을 눈여겨볼 부분이다

## 포인터 연산
포인터에 저장된 값은 부호없는 정수 (unsigend int) 이기 때문에 정수처럼 덧셈이나 뺄셈은 물론이고 증감연산이나 비교연산도 가능하다.

### [ 포인터와 증감연산자 ++ , -- ]
메모리에서 무조건 1바이트씩 이동하면서 값에 접근하는 것 보다 포인터의 타입에 따라 다르게 이동하면서 값을 읽어오는것이 더 유용하기 때문에 포인터의 대상의 크기에 따라 증가되는 값이 달라지도록 되어있다.

> 포인터 ptr 의 대상타입의 크기만큼 주소값이 증가한다.

이 특성은 포인터의 대상이 배열일 때 특히 유용하다. 배열요소 중 하나를 가리키고 있는 포인터의 값을 1 증가시키면 그 다음 배열요소를, 1 감소시키면 이전 배열요소를 가리키게 된다. 그래서 포인터에 배열의 첫 번째 요소의 주소를 저장한 다음 계속 증가시켜나가면서 *연산자를 함께 하용하면 배열의 모든 요소를 읽어 올 수 있다.

```c
  char* pc = (char*) 0x100;
  short* ps = (short*) 0x100;
  int* pi = (int*) 0x100;

  printf("pc : 0x%x , ps : 0x%x , pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);
  printf("pc : 0x%x , ps : 0x%x ,pi : 0x%x\n" , pc++ , ps++ , pi++);

/*
pc : 0x100 , ps : 0x100 , pi : 0x100
pc : 0x101 , ps : 0x102 ,pi : 0x104
pc : 0x102 , ps : 0x104 ,pi : 0x108
pc : 0x103 , ps : 0x106 ,pi : 0x10c
pc : 0x104 , ps : 0x108 ,pi : 0x110
*/
```

### *ptr++ 은 *(ptr++)? (*ptr)++?
'*ptr++' 은 포인터에서 자주 사용되는 중요한 식이다. '*' 와 '++' 모두 단항 연산자인데 어느 쪽이 더 우선순위가 높을까?

그렇다면 '*++ptr'의 경우는? 단항 연산자는 피연산자와 가까운 쪽부터 수행되니까 '++' 연산이 먼저 수행된다. 그래서 '*ptr++' 의 경우에서도 '++' 연산이 먼저 수행된다고 생각하면 기억하기 쉽다. 

그러면 '*ptr++' 이 '*(ptr++)'과 같다는 얘긴데, '++' 이 후위형이라서 헷갈리게 된다. 실제로는 '++'이 우선순위가 높지만, 후위형이라서 '*' 연산이 먼저 수행된다. 그래서 먼저 ptr 에 저장된 값을 가져온 다음에 ptr 의 값이 증가한다.

> *ptr++ == 값을 가져온 다음 ptr 의 값이 증가함

앞으로 '(*ptr)++' 보다는 '*ptr++' 을 더 자주 사용하게 될 것이다.

## 포인터의 덧셈과 뺄셈
포인터에 저장도니 값은 '부호없는 정수' 이므로, 이 값에 정수를 더하거나 빼는 것이 가능하다. 단지 좀 전에 배운것 처럼 일반적인 정수연산과 달리 포인터가 가리키는 대상의 타입에 따라 포인터의 값이 다르게 변한다.

포인터에 정수 n을 더하면, 실제로는 포인터의 값에 'n * sizeof(*ptr)' 을 더한것과 같은 결과를 얻는다.

```
ptr + 3 = 0x100 + (3 * sizeof(int))

0x100 + 12 = 0x10c
```

이번엔 뺄셈을 해보자 다음코드에서 변수 diff 에 저장되는 값은 얼마인가

```c
int arr[4];

int diff = &arr[2] - & arr[0]; 
```

'2 * sizeof(int)' 의 결과인 8을 예상했을 수도 있지만, 답은 2이다. 실제 주소값의 차이인 8을 얻고자 한다면 다음과 같이 'char*' 또는 'unsigned' 로 형변환 후에 뺄셈을 해야한다.

```c
int arr[4];
long long diff = &arr[2] - &arr[0];                       // diff 의 값은 2
long long diff = (char*) &arr[2] - (char*) &arr[0];       // diff 의 값은 8
long long diff = (unsigned) &arr[2] - (unsigned) &arr[0]; // diff 의 값은 8
```

형변환할 때 양쪽을 모두 같은 타입으로 형변환해야한다. 당연한 얘기지만 포인터의 뺄셈은 같은 타입만 가능하기 때문이다. 그리고 포인터의 값은 부호없는 정수이지만, 뺄셈의 결과는 음수일 수 있기때문에 변수 diff 의 타입을 부호있는 정수로 해야한다.

그러나 앞서 포인터의 형변환에서 언급한 것과 같이 이식성 문제가 발생할 수 있으므로 변수 diff 의 타입을 밑과 같이 'intptr_t'라는 부호있는 정수 타입으로 하는 것이 좋다. 이 타입을 사용하면 32 bit OS 나 64 bit OS 어느쪽에서나 코드의 변경없이 잘 동작한다.

> long long diff = &arr[2] - &arr[0] --> intptr_t diff = &arr[2] - &arr[0]


## void 포인터와 NULL
포인터는 메모리에 저장된 대상을 가리키기 위한 것이며, 어떤 대상을 가리키느냐에 따라서 포인터의 타입이 결정된다. 그런데 가리키는 대상의 타입이 없는 포인터도 있으며, 이를 'void 포인터' 라고 한다. void 포인터의 타입은 'void*' 이며 다음과 같이 선언한다.

> void* vp;

포인터 타입이 'void*' 이지만, 이 포인터가 가리키는 대상의 타입이 'void' 인것은 아니다. 여기서 'void' 의 의미는 타입이 정해져있지 않음을 의미할 뿐이다.
그래서 void 포인터에는 어떤 종류의 포인터의 값도 형변환 없이 대입이 가능하다.

