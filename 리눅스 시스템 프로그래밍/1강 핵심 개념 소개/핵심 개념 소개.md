## 표준

리눅스는 가장 중요하고 유력한 표준인 POSIX 와 SUS (Single UNIX Specification , 단일 유닉스 명세) 호환을 지키려고 노력한다.

POSIX 와 SUS는 특히 유닉스 호환 운영체제 인터페이스를 위한 C API를 명세하고 있는데 실질적으로 이 표준은 시스템 프로그래밍 , 혹은 최소한 유닉스 호환 시스템상에서의 시스템 프로그래밍에 대한 공통 부분을 기술하고 있다.

### 1. POSIX 와 SUS 표준 이야기

1980년대 중반 IEEE (Institute of Electrical and Electronics Foundation)의 창립자인 리차드 스톨만은 POSIX를 표준안 이름으로 제안했다.

이런 IEEE의 노력의 결과로 1988년 IEEE Std 1003.1-1998 (POSIX 1988)의 표준이 발표되었고 1990년 IEEE는 POSIX 표준을 IEEE Std 1003.1-1900(POSIX 1990)으로 개정했다. 실시간과 스레드 자원에 대한 표준은 각각 IEEE Std 1003.1b-1993(POSIX 1993 혹은 POSIX.1b)과 IEEE Std 1003.1c-1995(POSIX 1995 혹은 POSIX.1c)에 담겨있다.

2001년 POSIX 1990을 근간으로 하여 실시간과 스레드에 대한 표준까지 모두 포함한 단일 표준인 IEEE Std 1003.1-2001(POSIX 2001)이 발표됬다. 가장 최신 버전은 2008년 12월에 발표된 IEEE Std 1003.1-2008이다. 모든 POSIX의 핵심 표준은 POSIX.1로 줄여 부르며 2008년 개정판이 가장 최신 버전이다.

1980년대 후반부터 1990년 초반, 유닉스 시스템 업체들은 서로 자신의 유닉스 변종을 표준 유닉스 운영체제로 정의하고자 유닉스 전쟁을 치렀다. 몇몇 대형 유닉스 업체는 공개 스프트웨어 파운데이션 (OSF , Open Software Foundation) 과 X/Open 을 합쳐 오픈 그룹이라는 컨소시엄을 구성하고 공식 인증 , 백서 , 호환성 테스트를 제공했다.

1990년대 초반 유닉스 전쟁이 극에 달했고 오픈 그룹은 SUS를 발표했다. SUS는 POSIX 표준에 비해 비용이 저렴했던 이유로 빠르게 인기를 얻었다. 오늘날까지 SUS는 최신 POSIX 표준을 포함한다.

SUS의 최초 버전은 1994년에 발표되었다. 그리고 개정안인 SUSv2가 1997년에 발표되었고 2002년에는 SUSv3가 발표되었다. SUS 표준의 가장 최신 버전은 SUSv4이며 2008년에 발표되었다.

SUSv4는 IEEE Std 1003.1-2008과 다른 몇 가지 표준안을 포함해서 개정되었다. 이 책에서는 POSIX 표준에서 정의한 시스템 콜과 인터페이스를 다루겠다. SUS라고 하지 않고 POSIX라고 부르는 이유는 SUS가 POSIX를 포함하기 때문이다.

## 리눅스 프로그래밍의 개념

### 1. 파일과 파일시스템

파일은 리눅스에서 가장 기본적이고 핵심이 되는 추상화 개념이다. 리눅스는 모든것이 파일이라는 철학에 따른다. 따라서 모든 인터렉션은 실제로 파일이 아닌 것처럼 보일지라도 파일을 읽고, 파일에 쓰는 것으로 이루어진다.

파일에 접근하려면 먼저 파일을 열어야 한다. 파일은 읽기, 쓰기, 혹은 읽기/쓰기 모드로 열 수 있다. 이렇게 열린 파일은 그 파일에 대한 메타데이터와 연결된 고유한 기술자를 통해 참조할 수 있다. 리눅스 커널 내부에서 이 기술자(descriptor)는 정수 (int)로 표현되며 파일 디스크립터 (file descriptor)라고 부르며 흔히 줄여서 fd라고 부른다.

파일 디스크립터는 사용자 영역에서 공유되며 응용 프로그램이 파일에 접근할 때 직접 사용한다. 리눅스 시스템 프로그래밍 대부분은 바로 이 파일 디스크립터를 열고 조작하고 닫는 작업이다.

#### 일반파일

우리가 흔히 파일이라고 부르는 것은 일반 파일을 의미한다. 일반파일은 바이트 스트림이라고 부르는 연속적으로 나열된 바이트 배열에 저장된 데이터를 의미한다. 리눅스에는 파일을 위한 특별한 자료구조가 없다. 이 데이터에는 어떠한 값이라도 들어갈 수 있으며 어떤 구조로 저장해도 상관없다.

시스템 수준에서 살펴보면 리눅스는 바이트 스트림 외에 어떤 자료구조도 강제하지 않는다. VMS나 다른 운영체제에서는 레코드 같은 개념을 지원하는 고도화된 자료구조를 제공하지만 리눅스는 그렇지 않다.

파일은 바이트를 읽고 쓰는 것이 가능하다. 이런 작업은 파일 내부의 위치를 지정해서 수행할 수 있는데, 이 위치는 파일 오프셋(file offset) 혹은 파일 위치 (file position)이라고 한다.

파일 오프셋은 커널이 열린 파일마다 유지하는 메타데이터의 핵심이다. 파일이 처음 열리면 파일 오프셋은 0이다. 보통 파일은 바이트 단위로 읽고 쓰기 때문에 파일 오프셋 역시 바이트 단위로 증가하거나 감소한다. 직접 파일 오프셋을 지정할 수도 있는데 파일 끝을 넘길 수도 있다. 파일 끝을 넘어서는 위치에 바이트를 기록하면 파일 끝에서부터 지정한 위치까지 내용은 0으로 채워진다.

이렇게 파일의 끝을 넘어서는 윛에 데이터를 기록할 수는 있지만, 파일의 시작 위치보다 앞선 위치에 데이터를 기록하는 것은 불가능하다. 파일의 시작위치 보다 앞선 위치에 데이터를 기록한다는 것은 의미가 없을 뿐만아니라, 그걸 가능하게 해야 할 이유도 별도로 찾기 어렵기 때문이다. 파일 오프셋은 0부터 시작하며 음수 값이 될 수 없다.

파일 중간에 데이터를 기록하면 이전에 있던 데이터를 덮어쓴다. 따라서 파일 중간에 데이터를 쓰는 방법으로 파일은 확장하는 것은 불가능하다.

파일 쓰는 작업은 대부분 파일의 끝에서 일어나며 파일 오프셋의 최댓값은 이 오프셋을 저장하기 위해 사용하는 C 타입의 크기로 결정되며 최신 리눅스 시스템에서는 64비트 값이다.

파일 크기는 바이트 단위로 측정되는데 이를 파일 길이라고 한다. 다시 말하자만 길이는 단순히 파일을 구성하는 바이트 배열의 크기다. 파일 길이는 잘라내기(truncation) 연산을 통해 변경할 수 있다. 파일은 원래 크기보다 더 작은 사이즈로 잘라낼 수 있으며 이때 파일 끝에서 잘라낼 크기만큼의 바이트를 제거한다. 이름 때문에 헷갈릴 수 있는데, 잘라내기 연산을 통해 원래 크기보다 더 큰 크기로 자르는 것도 가능하다. 이 경우 파일 끝에 추가되는 새로운 데이터는 0으로 채워진다.

빈 파일 (길이가 0인)을 만들 수도 있으며 이때는 아무런 데이터도 포함하지 않는다. 최대 파일 길이는 최대 파일 오프셋 값과 동일하며 커널에서 파일을 관리하기 위해 사용하는 C 타입의 크기로 제한된다.

하나의 파일은 다른 프로세스나 심지어 동일한 프로세스에서 한 번 이상 열 수 있다. 파일은 열릴 때마다 고유한 파일 디스크립터를 반환한다. 반대로, 프로세스들끼리는 파일 디스크립터를 공유할 수 있다.

하나의 파일 디스크립터는 하나 이상의 프로세스에서 사용될 수 있다. 커널은 파일에 대한 동시 접근을 막지 않는다. 여러 개의 프로세스에서 동시에 같은 파일은 읽거나 쓰는 것이 가능하다.

이와 같은 동시 접근은 각가의 연산순서에 따라 다른 결과를 발생시키며 예측이 불가능하다. 사용자 영역의 프로그램은 이런 파일 동시 접근을 회피할 수 있도록 항상 신경써야 한다.

일반적으로 파일 이름을 통해 파일에 접근하지만 실제로 파일을 파일 이름과 직접적으로 연관되어 있지 않다. 파일은 inode (information node , 아이노드) 라고 하는 파일시스템 내에서만 고유한 정수 값으로 참조된다.

이 값은 inode 번호라고 하며 ino(i-number)라고 줄여 쓰기도 한다. inode 는 변경된 날짜, 소유자, 타입, 길이, 데이터 저장위치와 같은 파일에 관련된 메타데이터를 저장하고 있지만, 파일 이름은 저장하지 않는다. inode 는 유닉스 파일시스템에서 디스크에 저장된 물리적인 객체임과 동시에 리눅스 커널에서 자료구조로 표현되는 논리적인 개념이기도 하다.

#### 디렉터리와 링크

inode 번호로 파일에 접근하려면 귀찮은 데다 잠재적 보안 위협까지 있어서 보통 사용자 영역에서 파일에 접근할 때는 inode 대신 파일 이름을 사용한다. 디렉터리는 파일에 접근하기 위해 이름을 제공하는데 디렉터리는 inode 대신 사람이 읽을 수 있는 이름으로 나타낸다.

이 이름과 inode 쌍을 링크라고 한다. 사용하는 파일시스템에 맞게 이 링크를 관리하고 물리적으로 디스크에 저장하는 코드가 커널에 구현되어 있다. 개념적으로는 디렉터리는 일반 파일과 유사한 모습이지만 이름과 inode 의 맵핑만 저장한다는 점에서 차이가 있다. 커널은 이런 맵핑을 사용해서 이름으로 inode 를 찾는 작업을 수행한다.

사용자 영역 애플리케이션에서 어떤 파일을 열겠다고 요청하면 커널은 파일 이름이 포함된 디렉터리를 열고 파일을 찾는다.

커널은 파일 이름으로 inode 번호를 얻고 이렇게 얻은 inode 번호로 inode 를 찾는다. inode 에는 디스크에서 파일의 위치 같은 파일 관련 메타데이터가 있다.

초기 디스크에서는 루트 디렉터리 하나만 있다. 보통 루트 디렉터리 경로는 /로 표시한다.

하지만 이미 알고 있듯이 시스템에서는 수많은 디렉터리가 있다. 특정 파일을 찾기위해 어떤 디렉터리를 살펴봐야 하는지 어떻게 알 수 있을까?

앞서 말했지만 디렉터리는 일반 파일과 매우 유사하다. 실제 디렉터리도 inode 가 있다. 따라서 디렉터리 내부의 링크 역시 다른 디렉터리의 inode 를 가리킬 수 있다.

즉, 디렉터리는 다른 디렉터리 내부에 존재할 수 있고 계층적인 구조를 형성할 수 있게된다. 이를 활용해서 /home/blackbeard/concorde.png 처럼 우리에게 친숙한 파일 경로를사용할 수 있는 것이다.

이런 파일 경로를 열겠다고 요청하면 커널은 해당 파일 경로에 속한 각 디렉터리 엔트리 (directory entry , 커널 내부에서는 dentry 라고 부른다.) 를 탐색해서 다음 항목의 inode 를 찾는다.

위 예에서 커널은 /로 시작하고 home 을 가리키는 inode 를 얻은 다음 blackbeard 를 가리키는 inode 를 얻고, 최종적으로 concorde.png 의 inode 를 얻는다.

이 과정을 디렉터리, 혹은 경로 이름 찾기라고 한다. 리눅스 커널은 dentry 캐시를 사용해서 디렉터리 찾기 결과를 저장하고 나중에 일시적인 지역성을 활용해 탐색 속도를 높인다.

루트 디렉터리에서 시작하는 경로 이름은 언제나 완전하게 명시되어 있기 때문에 절대 경로라고 한다. 어떤 경로 이름은 완전하게 명시되어 있지 않으며 다른 디렉터리의 상대적인 위치로 표현한다. 이를 상대 결로 이름이라고 한다.

상대 경로 이름을 사용하면 커널은 현재 작업 디렉터리에서 경로 이름을 찾는다 예를 들어 todo/plunder를 찾는다면 현재 작업 디렉터리에서 todo 디렉터리를 탐색한다. 여기서 커널은 plunder를 가리키는 inode를 얻는다. 상대 경로 이름과 현재 작업 디렉터리를 합치면 완전한 디렉터리 이름을 얻을 수 있다.

비록 디렉터리를 일반 파일처럼 취급하지만, 커널은 사용자 영역에서 디렉터리를 일반 파일처럼 열고 조작하지 못하도록 제한한다.

그래서 디렉터리는 특수한 시스템 콜을 활용해서 조작해야 하는데 이를 위한 시스템 콜로는 링크 추가와 삭제가 있다. 사용자 영역에서 커널의 중재 없이 디렉터리를 조작할 수 있게 하면 아주 단순한 오류가 발생해도 파일 시스템을 전체를 망가뜨릴 수 있다.

#### 하드 링크

지금까지 살펴본 바로는 다른 이름으로 동일한 inode 를 가리키지 못하게 하는 방법은 없었다. 하지만 이런 방법도 가능한데, 여러 개의 링크들이 각각 자신의 이름을 동일한 inode 로 맵핑하고 있을때, 이를 하드 링크라고 한다.

하드 링크는 복잡한 파일시스템 구조에서 동일한 데이터를 여러 경로 이름이 가리킬 수 있게 허용한다. 하드 링크는 동일한 디렉터리에 존재하거나 둘 이상의 다른 디렉터리에 걸쳐 있어도 된다. 커널은 어느 경우에도 경로 이름을 가지고 올바른 inode 를 찾아낸다.

예를 들어 특정 데이터를 가리키고 있는 어떤 inode 는 /home/bluebeard/treasure.txt 와 /home/blackbeard/to_steal.txt로 하드 링크를 걸 수 있다.

파일 삭제는 디렉터리 구조에서 링크를 해제하는 작업에 관여하는데 파일 삭제는 단순히 디렉터리에서 이름과 inode 쌍을 삭제하면 끝난다. 하지만 리눅스는 하드 링크를 지원하므로 파일 시스템은 링크를 해제할 때마다 inode 와 관련 자료를 삭제할 수 없다. 파일 시스템 내에 다른 하드 링크가 존재한다면 어떻게 될까?

모든 링크가 삭제될때까지 파일을 삭제하지 못하도록 보장하기 위해 각 inode 는 파일 시스템 내에서 링크 카운터를 두어 자신을 가리키는 링크 개수를 추적한다. 파일 이름의 링크가 해제하면 링크 카운터가 하나 감소하며 링크 카운트가 0이 되면 파일시스템에서 inode 와 관련 자료를 실제로 삭제한다.

#### 심벌릭 링크

하드 링크가 다른 파일 시스템으로 확장되지 못하는 이유는 inode가 속한 파일시스템 외부에서는 inode 번호가 무의미하기 때문이다. 유닉스 시스템은 여러 파일시스템에 걸쳐 사용할 수 있도록 좀 더 단순하지만 덜 투명한 링크인 심벌릭 링크 (Symbolic link) 를 제공한다.

심벌릭 링크는 일반 파일처럼 생겼다. 심벌릭 링크도 독자적인 inode 및 데이터를 가지는데 이 데이터 안에는 링크로 연결할 파일의 완전한 경로 이름이 포함되어 있다. 이는 심벌릭 리읔가 다른 파일시스템에 들어 있는 파일과 디렉터리는 물론이고 심지어는 존재하지 않는 파일과 디렉터리를 가리킬 수도 있음을 의미한다.

존재하지 않는 파일을 가리키는 심벌릭 링크를 깨진 링크라고 한다.

하드 링크보다 심벌릭 링크가 오버헤드를 많이 초래하는 이유는 심벌릭 링크를 효과적으로 탐색하기 위해 심벌릭 링크와 그 링크로 연결된 파일 둘 다 다뤄야 하기 때문이다. 하드 링크에 추가적인 오버헤드가 없는 이유는 파일 시스템에서 링크가 둘 이상 걸린 파일에 접근하거나 하나만 걸린 파일에 접근하거나 구현상 차이가 없기 때문이다.

심벌릭 링크의 오버헤드는 매우 작지만 그래도 부정적인것으로 취급되고 있다.

심벌릭 링크 또한 하드 링크보다 투명성이 떨어진다. 하드 링크는 사용자 입장에서 봤을때 완전히 투명하다. 실제로 두 번 이상 링크된 파일을 찾아내는 작업이 더 어렵다.

반면에 심벌릭 링크를 저작하려면 특수한 시스템 콜이 필요하다. 이런 투명성 결여는 심벌릭 링크가 명료하게 생성되며 파일 시스템 내부 링크가 아닌 일종의 바로가기처럼 동작하기 때문에 종종 장점으로 작용하기도 한다.

#### 특수 파일

특수 파일은 파일로 표현되는 커널 객체이다. 지난 수년동안 유닉스 시스템은 적은 수의 특수 파일만 지원해왔다. 그중 리눅스는 네 종류의 특수 파일을 지원하는데 블록 디바이스 파일, 캐릭터 디바이스 파일, 네임드 파이프, 유닉스 도메인 소켓이 그 4가지 다.

특수 파일은 '모든 것이 파일'이라는 유닉스 철학에 맞게 파일시스템 위에 구현된 추상화 개념이며 리눅스는 특수 파일을 생성하는 시스템 콜을 제공한다.

유닉스 시스템에서는 하드웨어 장치에 대한 접근 또한, 파일을 거쳐 실행된다. 이런 파일이 파일 시스템에 있는 디바이스 파일인데, 일반 파일처럼 생기고 실제 일반파일처럼 동작한다. 디바이스 파일을 열고, 읽고 쓰는 방식으로 사용자 영역에서 하드웨어 장치로 접근을 허용하여 시스템에 있는 (물리적이거나 가상의) 하드웨어 장치를 조작한다.

유닉스에서 하드웨어 장치는 보통 캐릭터 디바이스와 블록 디바이스로 나뉘고 하드웨어 종류마다 독자적인 특수 디바이스 파일이 존재한다.

캐릭터 디바이스는 바이트록 구성된 선형 큐처럼 접근할 수있다. 디바이스 드라이버는 큐에 바이트를 하나씩 집어 넣고, 사용자 영역에서는 큐에 쌓인 순서대로 바이트를 읽어낸다. 키보드는 캐릭터 디바이스의 대표적인 예로, 사용자가 'peg'를 입력하면 애플리케이션은 키보드 디바이스에서 p,e,g를 순서대로 읽어낸다.

읽을 문자가 남아있지 않으면 디바이스는 EOF(End of File)을 반환한다. 글자가 빠지거나 순서가 바뀐 상태로 읽으면 키보드를 사용할 수 없을 것이다. 캐릭터 디바이스는 캐릭터 디바이스 파일로 접근한다.

반면에 블록 디바이스는 바이트 배열로 접근한다. 디바이스 드라이버는 위치 지정이 가능한 장치에 여러 바이트를 맵핑해 사용자 영역에서는 이 배열이 포함하고 있는 유효한 바이트에 임의로 접근할 수 있다.

예를 들어 12바이트를 읽은 다음에 7바이트를 일고 다시 12바이트를 읽어도 된다. 블록 디바이스는 보통 저장장치를 말하는데 하드 디스크, 플로피 드라이브, CD-ROM 드라이브, 플래시 메모리는 모두 블록 디바이스에 해당한다. 블록 디바이스 역시 블록 디바이스 파일을 통해 접근한다.

네임드 파이프 (First In, First Out 의 약자인 FIFO 로 부르기도 한다.)는 IPC (Inter-Process Communication) 메커니즘으로 특수 파일을 읽고 쓰는 파일 디스크립터 형태로 통신 채널을 제공한다.

일반 파이프는 특정 프로그램 출력을 파이프를 잇는 것처럼 다른 프로그램 입력으로 연결하기 위한 방법이다. 시스템 콜로 만들어지는 일반 파이프는 파일시스템이 아니라 메모리에 존재한다.

네임드 파이프는 일반 파이프와 동일하게 동작하지만, FIFO라는 특수한 파일을 거쳐 접근한다. 서로 무관한 프로세스도 이 파일에 접근하는 방식으로 프로세스 사이에 통신이 가능해진다.

마지막 유형으로는 소켓이 있다. 소켓은 서로 다른 프로세스끼리 통신할 수 있는 고급 IPC의 한 종류이며 같은 머신뿐만 아니라 다른 머신과도 통신이 가능하다. 실제로 소켓은 네트워크와 인터넷 프로그래밍의 근간을 이루고 있다.

로컬 머신 내부에서 통신을 ㅜ이해 사용하는 소켓 형태인 유닉스 도메인 소켓을 포함하여 소켓에는 많은 변종이 있다. 인터넷에서 통신하는 소켓은 통신 목적지를 파악하기 위해 호스트 이름과 포트를 사용하지만 유닉스 도메인 소켓은 파일시스템에 만들어진 특수 파일(소켓 파일)을 사용한다.

#### 파일시스템과 네임스페이스

다른 유닉스 시스템과 마찬가지로 리눅스는 파일과 디렉터리를 나타내기 위한 통한된 전역 네임스페이스를 제공한다. 몇몇 운영체제는 디스크와 드라이브를 분리해서 독립적인 네임스페이스로 할당한다.

예를 들어 플로피 디스크에 있는 파일은 A:\plank.jpg로 접근하지만, 하드 드라이브는 C:\로 접근한다. 유닉스에서는 플로피 드라이브에 잇는 파일은 /media/floopy/plank.jpg 라는 경로 이름 혹은 심지어 /home/captain/stuff/plank.jpg로 접근이 가능하다 다시말해 유닉스에서는 네임스페이스가 통합되어 있다.

파일시스템은 파일과 디렉터리를 정형적이고 유효한 계층 구조 안에 모아놓은 것이다. 파일시스템을 파일과 디렉터리라는 전역 네임스페이스 안에 개별적으로 추가하거나 제거할 수 있다.

이런 과정은 마운트 (추가)와 인마운트 (제거) 라고 한다. 개별 파일시스템이 마운트 되는 네임스페이스 상의 장소를 마운트 포인트라고 한다. 마운트된 파일시스템의 루트 디렉터리는 마운트 포인트에서 접근 가능하다. 예를 들어 CD를 /media/cdrom에 마운트하면 CD에 있는 파일시스템 루트는 마운트 포인트인 /media/cdrom에서 접근 가능하다. 가장 먼저 마운트된 파일시스템은 네임스페이스의 루트인 /에 위치하므로 루트 파일시스템이라고 한다.

리눅스시스템에는 항상 루트 파일시스템이 존재한다. 그 외 다른 파일시스템을 다른 마운트 포인트에 마운트하는 과정은 필요에 따라 선택한다.

리눅스는 메모리에만 존재하는 가상 파일시스템과 네트워크를 통해 다른 머신과 연결하는 네트워크 파일시스템을 지원하지만 일반적으로 파일시스템은 물리적으로 존재한다. (다시말해, 디스크에 저장된다.)

물리적인 파일시스템은 CD, 플로피 디스크 , SD 카드와 같은 블록 저장 디바이스에 존재한다. 어떤 디바이스는 파티션으로 나눠지기도 한다. 이는 디바이스를 여러 개의 파일시스템으로 나눠 따로 관리할 수 있다는 의미이다.

리눅스는 일반 사용자들이 주로 찾는 다양한 파일시스템을 지원한다. 여기에는 저장매체에 밀접한 파일시스템 (예를 들어 , ISO09660), 네트워크 파일시스템 (NFS), 네이티브 파일시스템(ext4) , 다른 유닉스에서 사용한느 파일이스템 (XFS), 심지어는 유닉스 계열이 아닌 파일시스템 (FAT)도 포함된다.

블록디바이스의 최소 접근 단위는 섹터다, 섹터는 디바이스의 물리적인 속성이다. 섹터는 2의 승수로 나타내며 512바이트가 가장 일반적이다. 블록 디바이스는 섹터보다 더 작은 데이터 다누이를 전송하거나 더 작은 데이터 단위에 접근하지 못한다. 모든 입출력은 섹터 하나 이상을 기준으로 일어난다.

물리적인 최소 접근 다누이가 섹터라면 파일시스템에서 논리적인 최소 접근 다누이는 블록이다. 블록은 파일시스템이 추상화된 개념으로 파일시스템이 존재하는 물리 매체와 무관한다. 블록은 보통 섹터 크기의 2의 배수이다. 블록은 일반적으로 섹터보다 더 크지만, 페이지 크기 (하드웨어 구성요소인 메모리 관리 유닛에서 지정 가능한 최소 단위) 보다는 작다. 보통 블록 크기는 512바이트 , 1,024바이트 , 4,096 바이트 이다.

전통적으로 유닉스 시스템은 시스템 내의 모든 사용자와 모든 프로세스가 볼 수 있는 단일 공유 네임스페이스만 존재한다. 리눅스는 혁신적인 방식으로 프로세스별 네임스페이스를 지원하여 개별 프로세스에서 선택적으로 시스템에 존재하는 파일과 디렉터리 계층 구조를 독자적으로 바라볼 수 있다. 기본적으로 각 프로세스는 부모의 네임스페이스를 상송받지만, 프로세스는 독자적인 마운트 포인트와 단일 루트 디렉터리로 독자적인 네임스페이스를 생성할 수 있다.

#### 프로세스

유닉스의 가장 기본 개념인 파일을 이해했다면 두 번째 개념인 프로세스를 볼 차례이다.

프로스세는 실행 중인 오브젝트 코드를 말하는데 언제나 활성화 상태로 실행중인 프로그램이다. 프로세스를 오브젝트 코드라 말햇지만, 정확히는 단순한 오브젝트 코드를 넘어 데이터,리소스, 상태 , 가상화된 컴퓨터를 포함한다.

프로세스는 커널이 이해하는 실행 파일 포맷으로 만들어져 실행 가능한 오브젝트 코드로부터 시작된다. 리눅스에서 가장 일반적인 실행 파일 포맷은 ELF (Executable and Linkable Format) 이다.

실행 파일은 여러 섹션으로 구성되는데 섹션에는 메타데이터, 코드, 데이터 등이 들어있다. 이 섹션은 오브젝트 코드가 담긴 바이트 배열이며 선형 메모리 공간에 적재된다. 섹션에 담긴 바이트는 접근 권한이 같으며 사용목적이 비슷하고 동일하게 취급된다. 가장 중요한 공통 섹션은 텍스트 섹션, 데이터 섹션, bss 섹션이다.

텍스트 섹션에는 실행가능한 코드나 상수, 변수와 같은 읽기 전용 데이터가 있으며 읽기 전용과 실행 가능으로 표시된다.

데이터 섹션에는 정의된 값을 할당한 C 변수와 같은 초기화된 자료가 있으며 일반적으로 읽고 쓰기가 가능하도록 표시된다.

bss 섹션은 초기화되지 않은 전역 데이터를 포함한다. C 표준에 따르면 C 전역 변수의 기본값을 반드시 0이므로 디스크에 저장된 오브젝트 코드에 0을 저장할 필요가 없다. 그 대신 오브젝트 코드는 단순히 bss 섹션에 초기화되지 않은 변수 목록을 유지하며 커널은 메모리에 올라오는 시점에서 모든 값이 0인 페이지를 이 섹션에 맵핑할 수 있다.

bss 섹션은 오로지 이 목적에 최적화 되어있다. bss 라는 이름은 block started by symbol 또는 block storage segment 에서 유래했다.

이외에도 ELF 파일에는 (재배치 불가능한 심벌을 포함한) 절대 섹션과 온갖 잡다한 데이터가 들어가는 미정의 섹션이 있다.

또한, 프로세스는 커널이 중재하고 관리하는 다양한 시스템 리소스과 관련이 있다. 프로세스는 일반적으로 시스템 콜을 이용해서 리소스를 요청하고 조작한다. 이런 리소스에는 타이머, 대기중인 시그널, 열린 파일, 네트워크 연결, 하드웨어 IPC 메커니즘등이 포함된다.

프로세스 리소스는 자신과 관련한 데이터의 통계 정보를 포함하고 있으며 해당 프로세스의 프로세스 디스크립터의 형태로 커널 내부에 저장된다.

프로세스는 가상화를 위한 추상 개념이다. 선점형 멀티태스킹과 가상 메모리를 지원하는 리눅스 커널은 가상화된 프로세서와 가상황된 메모리를 프로세스에 제공한다. 프로세스 관점에서 바라보면 마치 혼자서 시스템을 통제하고 있다는 착각에 빠진다. 다시 말해 스케쥴러를 통해 프로세스 여러 개가 실행되더라도 프로세스 각각의 전체 시스템을 독점하는 듯이 동작한다.

커널은 동작중인 모든 프로세스가 시스템 프로세스를 공유하도록 빈틈없고 투명하고 프로세스를 선점하고 스케줄링한다. 프로세서 입장에서는 동작 방식에 대한 차이점을 결로 알지 못한다. 또한, 커널은 각 프로세스에 단일 선형 주소 공간 (Single Linear Address Space)를 제공하므로 마치 프로세스 홀로 시스템에 존재하는 모든 메모리를 제어하는 것처럼 보인다.

커널은 가상 메모리와 페이징 기법을 사용해서 프로세스마다 다른 주소 공간에서 동작하도록 만들기 때문에 여러 프로세스가 시스템상에 공존할 수 있는 것이다. 최신 프로세스는 운영체제가 독립적인 여러 프로세스의 상태를 동시에 관리할 수 있도록 하여 커널은 이런 하드웨어의 도움을 받아 가상화를 관리한다.

#### 스레드

각 프로세스는 실행 스레드 (일반적으로 그냥 스레드라고 하는)를 하나 이상 포함한다. 스레드는 프로세스 내부에서 실행하는 활동 단위이며, 코드를 실행하고 프로세스 동작 상태를 유지하는 추상 개념이다.

프로세스는 대부분 스레드 하나로만 구성되어 있는데 이를 싱글스레드라고 한다. 여러 스레드를 포함하는 프로세스를 멀티스레드라고 한다.

유닉스의 간결함을 중시하는 철학과 빠른 프로세스 생성 시간, 견고한 IPC 매커니즘 때문에 전통적으로 유닉스 프로그램은 싱글 스레드였고 스레드 기반을 옮겨가려는 요구사항이 비교적 적었다.

스레드는 (비스레드로 동작하는 프로세스 스택과 마찬가지로 독자적인 지역 변수를 저장하는) 스택, 프로세서 상태 , 오브젝트 코드의 현재 위치 (흔히 프로세서에 탑재된 명령어 포인터 instruction pointer 에 저장되어 있다.)를 포함한다.

기타 프로세스에 남아 있는 대부분의 리소스는 모든 스레드가 공유한다. 이런 방식으로는 스레드는 가상 메모리를 공유하고 가상 프로세스를 관리한다.

내부적으로 리눅스 커널은 독특한 관점으로 스레드를 구현한다. 스레드는 단순히 (특히 주소 공간을 비롯하여) 몇몇 리소스를 공유하는 일반적인 프로세스일 뿐이다.

사용자 영역에서 리눅스는 (Pthread 라고 하는) POSIX 1003.1c 에 따라 스레드를 구현한다. glibc 의 일부인 현재 리눅스 스레드 구현 이름은 NPTL (Native POSIX Threading Library)이다.

#### 프로세스의 계층 구조

각각의 프로세스는 pid (프로세스 ID) 라고 하는 고유한 양수 값으로 구분된다. 첫번째 프로세스의 pid 는 1이며 그 뒤로 생성되는 프로세스는 새로운 pid 를 받는다.

리눅스에서 프로세스는 프로세스 트리라는 엄격한 계층 구조를 형성한다. 일반적으로 프로세스 트리는 init 프로그램으로 알려진 첫 번째 프로세스가 루트가 된다. 새로운 프로세스는 fork() 시스템 콜로 만들어 진다.

이 시스템 콜은 호출하는 프로세스를 복사해서 다른 프로세스를 새로 만든다. 원본 프로세스를 부모라고 하며 새로 만든 프로세스를 자식이라고 한다.

첫번째 프로세스를 제외한 나머지 모든 프로세스에는 부모가 있다. 부모 프로세스가 자식 프로세스보다 먼저 종료되면 커널은 고아가 된 자식 프로세스를 init 프로세스에 입양시킨다.

프로세스가 종료되면 시스템에서 바로 제거되지 않고 프로세스 일부를 메모리에 계속 유지해서 자식 프로세스가 종료 될 때 부모 프로세스가 사앹를 검사할 수 있도록 한다. 이를 '종료된 프로세스를 기다린다'고 표현한다.

부모 프로세스가 종료된 자식 프로세스를 기다렸다면 자식 프로세스는 완전히 종료된다. 그런데 프로세스가 종료되었는데 기다리는 부모 프로세스가 없다면 이때, 좀비가 탄생한다. 일상적으로 init 프로세스는 자기에게 딸린 자식 모두를 기다려서 새로 입양된 프로세스가 영원히 좀비로 남지 않도록 보살핀다.

### 3. 사용자와 그룹

리눅스에서 권한은 사용자와 그룹형태로 제공된다. uid(사용자 ID)는 고유한 양수 값이며, 사용자를 구분한다. 따라서 프로세스 마다 자신을 실행하는 사용자가 누구인지 파악하는 용도로 uid 가 하나 붙으며 이를 프로세스의 실제 uid라고 한다. uid는 리눅스 커널 내부에서 사용자를 나타내는 유일한 개념이다. 하지만 다행히 사용자는 자신과 다른 사용자를 숫자가 아닌 사용자 이름으로 참조한다.

사용자 이름에 대응하는 uid 는 /etc/passwd 파일에 저장되어 있으며 라이브러리 루틴들은 이 파일을 참조해서 사용자가 입력한 사용자 이름을 그에 대응하는 uid로 맵핑할 수 있게 된다.

로그인 과정에서 사용자는 이름과 암호를 login 프로그램에 전달한다. 사용자가 입력한 이름과 암호가 올바르면 login 프로그램은 /etc/passwd 에 지정되어 있는 사용자 로그인 셸을 실행해서 셸의 uid를 사용자 uid 로 바꾼다.

자식 프로세스는 부모 프로세스의 uid를 상속받는다. uid 0 는 root(루트)라는 특수 사용자를 가리킨다. root 사용자는 특별한 권한이 있으며 시스템에서 거의 모든 작업을 실행할 수 있다. 예를 들어 root 사용자만이 프로세스의 uid를 바꿀 수 있다. 따라서 login 프로그램은 루트로 동작한다.

실제 uid 이외에, 프로세스마다 유효 uid, 저장된 uid, 파일시스템 uid 가 있다. 실제 uid는 항상 프로세스를 시작한 사용자를 나타내지만 유효 uid는 다른 사용자 권한으로 프로세스를 실행하도록 만드는 다양한 규칙에 따라 바뀔 수도 있다.

저장된 uid 는 원래 유효한 uid를 저장하며 이 값은 사용자가 전환하기를 원할지도 모르는 유효 uid 값을 결정하기 위해 쓰인다. 파일 시스템 uid 는 일반적으로 유효 uid 와 같으며 파일시스템 접근을 검증하는 데 쓰인다.

모든 사용자는 하나 이상의 그룹에 속해있다. 주 그룹이나 로그인 그룹은 /etc/passwd 에 지정하며 추가 그룹은 /etc/group에 지정한다.

따라서 프로세스마다 gid(그룹 ID)가 대응되어 실제 gid , 유효 gid , 저장된 gid , 파일시스템 gid를 갖게 된다. 일반적으로 프로세스는 사용자 로그인 그룹과 관련이 있으며 추가 그룹과는 관련이 없다.

### 4. 시그널

시그널은 비동기식 단방향 알림 메커니즘이다. 커널에서 프로세스로, 프로세스에서 다른 프로세스로, 아니면 프로세스 자기 자신에게 시그널을 보낼 수 있다. 일반적으로 시그널은 세그멘테이션 폴트 (Segmentation Fault)나 사용자가 Ctrl+C를 누르는 경우와 같이 프로세스에 특정 사건이 발생했음을 알려준다.

리눅스 커널에는 대략 30개 정도의 시그널이 있다. (정확한 숫자는 아키텍처마다 다르다) 각 시그널은 상수와 이름으로 표현되는데 예를 들어 x86-64 에서 터미널이 끊겼을 때 시그널을 보내기 위해 사용되는 SIGHUP는 1로 표현된다.

즉시 프로세스를 종료하도록 만드는 SIGKILL 과 즉시 프로세스를 머추게 만드는 SIGSTOP 을 제외하고 프로세스는 시그널을 받았을 때 어떻게 해야 할지 제어가 가능하다.

프로세스를 종료하거나 프로세스를 종료하고 메모를ㄹ 덤프하거나 프로세스를 멈추거나 아무 작업도 하지 않은 기본 동작을 그대로 따를 수도 있다. 아니면 프로세스가 명시적으로 시그널을 무시하거나 독자적으로 처리하도록 결정해도 된다.

시그널은 비동기적이기 때문에 시그널 핸들러가 비동기-안전한 (시그널-안전 하다고도 함) 함수만을 실행하도록 함으로써, 인터럽트 된 장소의 고크가 망가지지 않도록 해야한다.

### 5. 프로세스 간 통신

프로세스 사이에서 일어난느 정보 교환과 알림은 운영체제가 담당한느 가장 중요한 작업이다.

리눅스 커널은 시스템 V와 POSIX에서 정의하고 표준화한 메커니즘은 물론이고 한두가지 독자적인 메커니즘을 포함해서 과거부터 내려오는 유닉스 IPC 매커니즘을 대부분 구현한다.

리눅스에서 지원하는 IPC 메커니즘은 파이프 , 네임드 파이프, 세마포어, 메시지 큐, 공유 메모리, 퓨텍스가 있다.

### 6. 에러 처리

에러 검사 및 처리의 중요성은 두말할 필요도 없다. 시스템 프로그래밍에서 에러는 함수 리턴 값으로 확인이 가능하며 특수한 변수인 errno 로 에러가 발생한 구체적인 이유를 알 수 있다.

glibc 라는 라이브러리와 시스템 콜 양쪽을 지원하도록 errno 값을 공정하게 제공한다. 이 책에서 다루는 다양한 인터페이스는 이런 메커니즘을 사용해서 에러를 주고받는다.

정확한 값은 함수에 따라 다르겠지만 보통 에러가 발생하면 -1 을 반환한다. 이 에러 값은 호출한 측에서 에러가 발생했음을 알려주지만 자세한 에러 이유는 알려주지 않는다. 이때 에러 원인을 찾아내기 위해 errno 변수를 사용한다.

errno 변수는 <errno.h> 헤더에 다음과 같이 정의되어 있다,

```c
extern int errno;
```

이 값은 errno 에 값을 대입한 함수를 호출한 직후에만 유효하다. 연이어 다른 함수를 실행하면 이 값이 바뀌므로 주의해야 한다.

errno 변수는 직접 읽고 쓸 수 있으며 변경 가능한 변수 (lvalue)다. errno 값은 그 에러에 대한 설명에 맵핑되어 있다.

선행처리기 구문인 #define 으로 지정한 문자열 역시 숫자인 errno 값에 대응된다. 예를 들어 선행처리기는 #define 을 사용해서 '접근 거부'를 나타내는 EACCESS 를 1로 정의한다.

| 선행처리기 문자열 정의 |              설명               |
| :--------------------: | :-----------------------------: |
|         E2BIG          |        너무 긴 인자 목록        |
|        EACCESS         |            접근 거부            |
|         EAGAIN         |             재시도              |
|         EBADF          |        잘못된 파일 번호         |
|         EBUSY          | 이미 사용중인 디바이스나 리소스 |
|         ECHILD         |       자식 프로세스 없음        |
|          EDOM          |  함수 영역을 넘어선 수학 인자   |
|         EEXIST         |       이미 존재하는 파일        |
|         EFAULT         |           잘못된 주소           |
|         EFBIG          |          너무 큰 파일           |
|         EINTR          |   인터럽트가 걸린 시스템 호출   |
|         EINVAL         |       유효하지 않은 인자        |
|          EIO           |           입출력 에러           |
|         EISDIR         |           디렉터리임            |
|         EMFILE         |      열린 파일이 너무 많음      |
|         EMLINK         |         너무 많은 링크          |
|         ENFILE         |        파일 테이블 넘침         |
|         ENODEV         |       그럼 디바이스 없음        |
|         ENOENT         |   그런 파일이나 디렉터리 없음   |
|        ENOEXEC         |      잘못된 실행 파일 형식      |
|         ENOMEM         |           메모리 부족           |
|         ENOSPC         |    디바이스에 남은 공간 없음    |
|        ENOTDIR         |          디렉터리 아님          |
|         ENOTTY         |    부적절한 입출력 제어 연산    |
|         ENXIO          |    그런 디바이스나 주소 없음    |
|         EPERM          |       허용되지 않은 연산        |
|         EPIPE          |           파이프 깨짐           |
|         ERANGE         |          너무 긴 결과           |
|         EROFS          |      읽기 전용 파일 시스템      |
|         ESPIPE         |       유효하지 않은 탐색        |
|         ESRCH          |       그런 프로세스 없음        |
|        ETXTBSY         |    이미 사용중인 텍스트 파일    |
|         EXDEV          |       적절하지 않은 링크        |
|         etc...         |                                 |

C 라이브러리는 errno 값을 그에 맞는 문자열 표현으로 변환하는 함수를 몇가지 제공하고 있다. 이런 함수는 사용자에게 에러를 알려줄 때 사용한다. 흔히 선행처리기 정의와 errno를 직접 활용해서 에러 검사와 처리 작업을 실행한다.

이런 용도로 사용하는 함수로 perror()가 있다.

```c
#include <stdio.h>

void perror(const char* str)
```

이 함수는 str 이 가리키는 문자열 뒤에 콜론(:) 을 붙인 다음에 errno 가 기술하는 현재 에러를 문자열로 바꿔 표준 에러 (stderr : standard error)로 내보낸다. 활용도를 높이려면 실패한 함수 이름을 문자열에 포함해주면 좋다.

C 라이브러리는 strerror() 와 strerror_r() 함수를 제공한다. strerror() 함수의 원형은 다음과 같다.

```c
#include <string.h>

char* strerror (int errnum);
```

strerror_r() 함수의 원형은 다음과 같다

```c
#include <string.h>

int strerror_r (int errnum , char* buf , size_t len);
```

strerror() 함수는 errnum 에러에 대한 설명이 담긴 문자열에 대한 포인터를 반환한다. 문자열 내용을 애플리케이션에 의해 변경되지는 않지만 연속해서 perror() 와 strerror() 를 호출할 경우에는 바뀔수도 있다.

이런 의미에서 이 함수는 스레드 세이프 하지 않다.

strerror_r() 함수는 스레드에서 사용할 수 있다. 이 함수는 buf 가 가리키는 지점부터 len 만큼 버퍼를 채운다. 성공하면 strerror_r는 0을 반환하고 실패하면 -1을 반환한다.

웃기는 이야기지만 여기서도 에러가 발생하면 errno 를 설정한다.

어떤 함수에서는 반환 타입의 전체 범위가 유효한 반환값인 경우도 있다. 이런 경우 호출 전에 errno 를 0으로 초기화한 후에 함수를 호출하여 errno 를 검사한다.

예를 얼어 다음과 같다.

```c
errno = 0;
arg = strtoul(buf , NULL , 0);
if (errno)
  perror("strtoul");
```

흔히 하는 실수로 라이브러리나 시스템 콜에서 errno 값을 바꿀수 있다는 사실을 잊은 채 errno 값을 검사하는 경우가 있다 예를 들면 다음 코드에는 버그가 있다.

```c
if (fsync (fd) == -1) {
  fprintf(stderr , "fsync faild!\n");
  if (errno == EIO) {
    fprintf(stderr , "I/O error no %d!\n" , fd);
  }
}
```

만일 함수를 여러 번 호출하면서 errno 값을 보존해야 한다면 다른 곳에 따로 저장해야 한다.

```c
if (fsync (fd) == -1) {
  const int err = errno;
  fprintf(stderr , "fsync faild!\n");
  if (err == EIO) {
    fprintf(stderr , "I/O error no %d!\n" , fd);
    exit(EXIT_FAILURE);
  }
}
```

이 절 초반에 살펴보았듯이 싱글슽레드 프로그램에서 errno 는 전역변수이다. 하지만 멀티스레드 프로그램에서 errno 는 스레드 별로 저장되므로 스레드에서 사용이 가능하다.
