## 파일열기

파일에 접근하는 가장 기본적인 방법은 read() , write() 시스템 콜이다. 하지만 파일에 접근하기에 앞서 open() , creat() 시스템 콜을 사용해서 파일을 열어두고, 다 쓴 다음에는 close() 시스템 콜로 파일을 닫아야 한다.

### 1. open() 시스템 콜

open() 시스템 콜을 사용해서 파일을 열고 파일 디스크립터를 얻는다

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char* name , int flags);
int open(const char* name , int flags , mode_t mode);
```

open() 시스템 콜은 경로 이름이 name 인 파일을 파일 디스크립터에 맵핑하고, 성공하면 이 파일 디스크립터를 반환한다. 파일 오프셋은 파일의 시작지점인 0으로 설정되며 파일은 flags 로 지정한 플래그에 대응하는 접근모드로 열리게 된다.

#### open() 플래그

flags 인자는 O_RDONLY , O_WRONLY , O_RDWR 중 하나를 포함해야 한다.

예를 들어 다음 코드는 읽기 전용 모드로 /home/kidd/madagascar 파일을 연다

```c
int fd;

fd = open("/home/kidd/madagascar" , O_RDONLY);

if (fd == -1)
  /*에러*/
```

쓰기 전용 모드로 열린 파일은 읽기 작업이 불가능하며 반대의 경우도 마찬가지다. open() 시스템 콜을 호출한 프로세스는 호출 시 사용한 플래그에 맞는 충분한 접근 권한을 확보해야 한다.

flags 매개 변수에 비트 OR 연산으로 다음 값 중 하나 이상을 추가해서 열기 동작을 변경할 수 있다.

|    flags    |                                                                                                                                                             설명                                                                                                                                                              |
| :---------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|  O_APPEND   |                                                                                                                                          덧붙이기 모드, 오프셋을 파일 끝을 가리킨다                                                                                                                                           |
|   O_ASYNC   |                                                                                         특정파일에서 읽기나 쓰기가 가능해질때 시그널 (기본값으로 SIGIO)이 발생한다. 이 플래그는 일반 파일이 아니라 터미널과 소켓에만 사용할 수 있다.                                                                                          |
|  O_CLOEXEC  | 열린 파일에 close-on-exec 플래그를 설정한다. 새 프로세스를 실행하면 이 파일은 자동으로 닫힌다. 이 플래그를 설정하면 fcntl() 함수를 이용해서 따로 FD_CLOSEXEC플래그를 설정할 필요가 없다. close-on-exec 플래그를 설정하면 새 프로세스가 생성되면서 기존의 파일 디스크립터를 복사해서 생기는 경쟁 상태를 사전에 방지할 수 있다. |
|   O_CREAT   |                                                                                                                                        name 에 적은 파일이 없으면 파일을 새로 만든다.                                                                                                                                         |
|  O_DIRECT   |                                                                                                                                            직접 일출력을 수행하기 위해 파일을 연다                                                                                                                                            |
| O_DIRECTORY |                                                                                                        name 이 디렉터리가 아니면 open() 호출이 실패한다. 이 플래그는 opendir() 라이브러리 호출을 내부적으로 사용한다.                                                                                                         |
|   O_EXCL    |                                                                                                              O_CREAT 와 함께 이 플래그를 사용하면 name 으로 지정한 한 파일이 이미 있을때 open() 호출이 실패한다.                                                                                                              |
| O_LARGEFILE |                                                                                                        2기가바이트를 초과하는 파일을 열기 위해 64비트 오프셋을 사용한다. 이 플래그는 64비트 아키텍처를 내재 해야한다.                                                                                                         |
| O_NOATIME+  |              읽기에 의해서 파일의 마지막 접근 시간이 갱신되지 않도록 한다. 이 플래그는 백업이나 인덱싱, 또는 시스템 내에 존재하는 모든 파일을 읽어야 하는 프로그램에서 파일을 읽을때마다 해당 inode를 갯ㅇ신하기 위해 발생하는 쓰기 작업을 방지할 수 있어 유용하다. 리눅스 커널 2.6.8이상에서만 사용이 가능하다.              |
|  O_NOCTTY   |                                                                              name 이 터미널 디바이스 (예를 들어 /dev/tty)를 가리키면 프로세스에 현재 제어중인 터미널이 없더라도 프로세스의 제어 터미널이 되지 않는다. 주주 쓰는 플래그는 아니다.                                                                              |
| O_NOFOLLOW  |                                                      name 이 심벌릭 링크라면 open() 호출이 실패한다. 예를 들어 name 이 /etc/ship/plank.txt 인 데 plank.txt 가 심벌릭 링크라면 실패한다. 하지만 etc 나 ship 이 심벌릭 링크지만 plank.txt가 심벌릭 링크가 아니면 성공한다.                                                      |
| O_NONBLOCK  |                                                                                가능한 경우 파일을 논블록킹 모드로 연다. open() 호출이나 다른 연산은 입출력 과정에서 프로세스를 막고(블록)있지않는다. FIFO 용으로만 이런 동작 방식을 정의한다.                                                                                 |
|   O_SYNC    |            파일을 동기식 입출력용으로 연다. 데이터를 물리적으로 디스크에 쓰기 전까지는 쓰기 연산이 완료되지 않는다. 일반적인 읽기 연산은 이미 동기식이므로 읽기와 관련해서 이 플래그는 영향을 미치지 않는다. (POSIX는 추가적으로 O\_)DSYNC 와 O_RSYNC를 정의하고 있지만 리눅스에서 이 두 플래그는 O_SYNC 와 같다.             |
|   O_TRUNC   |                                                                                                          파일이 존재하고, 일반파일이며 flags 인자에 쓰기가 가능하도록 명시되어 있으면 파일 길이를 0으로 잘라버린다.                                                                                                           |

### 2. 새로운 파일의 소유자

새로운 파일 소유자를 결정하는 작업은 간단하다. 파일의 소유자의 uid는 파일을 생성한 프로세스의 euid (유효 uid)이다.

소유 그룹을 결정한느 작업은 좀 더 복잡하다. 기본 동작 방식에 따르면 파일 그룹은 파일을 생성한 프로세스의 egid (유효 gid)로 설정한다. 이는 시스템 V 동작 방식이며 (상당수의 리눅스가 이 방식을 따른다.) 리눅스가 따른 표준 작업 방식이다.

하지만 어려운것은 파일의 그룹이 사우이
